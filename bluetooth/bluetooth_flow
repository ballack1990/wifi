BluetoothSettings.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void onActivityCreated(Bundle savedInstanceState) {
            final SettingsActivity activity = (SettingsActivity) getActivity();
            mSwitchBar = activity.getSwitchBar();

            mBluetoothEnabler = new BluetoothEnabler(activity, mSwitchBar);             // 创建BluetoothEnabler对象
            mBluetoothEnabler.setupSwitchBar();
        }
    }
---------------------------------------------------------------------------------------------------------------->
BluetoothEnabler.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public BluetoothEnabler(Context context, SwitchBar switchBar) {
            mContext = context;
            mSwitchBar = switchBar;
            mSwitch = switchBar.getSwitch();
            mValidListener = false;

            LocalBluetoothManager manager = LocalBluetoothManager.getInstance(context);     // 获取LocalBluetoothManager对象
            if (manager == null) {
                // Bluetooth is not supported
                mLocalAdapter = null;
                mSwitch.setEnabled(false);
            } else {
                mLocalAdapter = manager.getBluetoothAdapter();                              // 获取LocalBluetoothAdapter对象
            }
            mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
        }

        public void onSwitchChanged(Switch switchView, boolean isChecked) {
            if (mLocalAdapter != null) {
                mLocalAdapter.setBluetoothEnabled(isChecked);                               // 打开/关闭 蓝牙
            }
        }
    }
------------------------------------------------------------------------------------------------------------------>
LocalBluetoothManager.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public static synchronized LocalBluetoothManager getInstance(Context context) {
            if (sInstance == null) {
                LocalBluetoothAdapter adapter = LocalBluetoothAdapter.getInstance();        // 获取LocalBluetoothAdapter对象
                if (adapter == null) {
                    return null;
                }
                // This will be around as long as this process is
                Context appContext = context.getApplicationContext();
                sInstance = new LocalBluetoothManager(adapter, appContext);                 // 第一次调用，创建LocalBluetoothManager对象
            }

            return sInstance;
        }

        private LocalBluetoothManager(LocalBluetoothAdapter adapter, Context context) {
            mContext = context;
            mLocalAdapter = adapter;                                                        // 构造的时候传入Adapter

            mCachedDeviceManager = new CachedBluetoothDeviceManager(context);
            mEventManager = new BluetoothEventManager(mLocalAdapter,
                    mCachedDeviceManager, context);
            mProfileManager = new LocalBluetoothProfileManager(context,
                    mLocalAdapter, mCachedDeviceManager, mEventManager);
        }

        public LocalBluetoothAdapter getBluetoothAdapter() {                                // 返回LocalBluetoothManager getInstance创建的Adapter
            return mLocalAdapter;
        }
    }
------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        static synchronized LocalBluetoothAdapter getInstance() {
            if (sInstance == null) {
                BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();        // 第一次调用，创建BluetoothAdapter对象
                if (adapter != null) {
                    sInstance = new LocalBluetoothAdapter(adapter);
                }
            }

            return sInstance;
        }

        private LocalBluetoothAdapter(BluetoothAdapter adapter) {
            mAdapter = adapter;                                                         // 保存BluetoothAdapter对象
        }
    }
---------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public static synchronized BluetoothAdapter getDefaultAdapter() {
            if (sAdapter == null) {
                IBinder b = ServiceManager.getService(BLUETOOTH_MANAGER_SERVICE);       // 获取bluetooth_manager服务
                if (b != null) {
                    IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);   // 获取BluetoothManager对象
                    sAdapter = new BluetoothAdapter(managerService);                    // 第一次调用，创建BluetoothAdapter对象
                } else {
                    Log.e(TAG, "Bluetooth binder is null");
                }
            }
            return sAdapter;
        }

        BluetoothAdapter(IBluetoothManager managerService) {
            if (managerService == null) {
                throw new IllegalArgumentException("bluetooth manager service is null");
            }
            try {
                mService = managerService.registerAdapter(mManagerCallback);            // 向服务注册Adapter
            } catch (RemoteException e) {Log.e(TAG, "", e);}
            mManagerService = managerService;
            mLeScanClients = new HashMap<LeScanCallback, ScanCallback>();
        }
    }
------------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void setBluetoothEnabled(boolean enabled) {
            boolean success = enabled
                ? mAdapter.enable()
                : mAdapter.disable();

            if (success) {
                setBluetoothStateInt(enabled
                        ? BluetoothAdapter.STATE_TURNING_ON
                        : BluetoothAdapter.STATE_TURNING_OFF);
            } else {
                if (Utils.V) {
                    Log.v(TAG, "setBluetoothEnabled call, manager didn't return " +
                            "success for enabled: " + enabled);
                }

                syncBluetoothState();
            }
        }
    }
------------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public boolean enable() {
            if (isEnabled() == true){
                if (DBG) Log.d(TAG, "enable(): BT is already enabled..!");
                return true;
            }
            try {
                return mManagerService.enable();                                // 调用底层服务打开蓝牙
            } catch (RemoteException e) {Log.e(TAG, "", e);}
            return false;
        }
    }
------------------------------------------------------------------------------------------------------------------------>
现在来展开一下mManagerService,可以看到上面的定义是:
IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);

private final IBluetoothManager mManagerService;
mManagerService = managerService;

------------------------------------------------------------------------------------------------------------------------>
IBluetoothManager.aidl(z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        interface IBluetoothManager
        {
            IBluetooth registerAdapter(in IBluetoothManagerCallback callback);
            void unregisterAdapter(in IBluetoothManagerCallback callback);
            void registerStateChangeCallback(in IBluetoothStateChangeCallback callback);
            void unregisterStateChangeCallback(in IBluetoothStateChangeCallback callback);
            boolean isEnabled();
            boolean enable();
            boolean enableNoAutoConnect();
            boolean disable(boolean persist);
            IBluetoothGatt getBluetoothGatt();

            boolean bindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);
            void unbindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);

            String getAddress();
            String getName();
        }
    }
------------------------------------------------------------------------------------------------------------------------>
在下面可以看到，是BluetoothManagerService服务实现的IBluetoothManager.Stub接口：
那么BluetoothManagerService服务是哪里启动的：
SystemServer.java (z:\home\ballack\prj\rk3288\frameworks\base\services\java\com\android\server)
->  {
        private void run() {
            startOtherServices();
        }
    
        private void startOtherServices() {
            Slog.i(TAG, "Bluetooth Manager Service");
            bluetooth = new BluetoothManagerService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
        }
    }
------------------------------------------------------------------------------------------------------------------------>
回到上面提到的：  
mManagerService.enable(); 

BluetoothManagerService.java (z:\home\ballack\prj\rk3288\frameworks\base\services\core\java\com\android\server)
->  {
        class BluetoothManagerService extends IBluetoothManager.Stub {
            BluetoothManagerService(Context context) {
                mHandler = new BluetoothHandler(IoThread.get().getLooper());
            }
        }

        public boolean enable() {
            persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
            sendEnableMsg(false);
        }

        private void sendEnableMsg(boolean quietMode) {
            mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_ENABLE,
                        quietMode ? 1 : 0, 0));
        }

        private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();

                if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
                    synchronized(mReceiver) {
                        if (mEnableExternal && isBluetoothPersistedStateOnBluetooth()) {
                            //Enable
                            if (DBG) Log.d(TAG, "Auto-enabling Bluetooth.");
                            sendEnableMsg(mQuietEnableExternal);
                        }
                    }

                    if (!isNameAndAddressSet()) {
                        //Sync the Bluetooth name and address from the Bluetooth Adapter
                        if (DBG) Log.d(TAG,"Retrieving Bluetooth Adapter name and address...");
                        getNameAndAddress();
                    }
                }
            }
        }

        public void getNameAndAddress() {
            if (DBG) {
                Log.d(TAG,"getNameAndAddress(): mBluetooth = " + mBluetooth +
                        " mBinding = " + mBinding);
            }
            Message msg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);         // 发送MESSAGE_GET_NAME_AND_ADDRESS消息！！
            mHandler.sendMessage(msg);
        }

        private class BluetoothServiceConnection implements ServiceConnection {

            /* Called when a connection to the Service has been established, with the 
               {@link android.os.IBinder} of the communication channel to the Service. 
            */
            public void onServiceConnected(ComponentName className, IBinder service) {                      
                Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_SERVICE_CONNECTED);  // 发送MESSAGE_BLUETOOTH_SERVICE_CONNECTED消息！！ 
                if (className.getClassName().equals("com.android.bluetooth.btservice.AdapterService")) {
                    msg.arg1 = SERVICE_IBLUETOOTH;
                } else if (className.getClassName().equals("com.android.bluetooth.gatt.GattService")) {
                    msg.arg1 = SERVICE_IBLUETOOTHGATT;
                } else {
                    Log.e(TAG, "Unknown service connected: " + className.getClassName());
                    return;
                }
                msg.obj = service;
                mHandler.sendMessage(msg);
            }

            public void onServiceDisconnected(ComponentName className) {
                Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED);
                if (className.getClassName().equals("com.android.bluetooth.btservice.AdapterService")) {
                    msg.arg1 = SERVICE_IBLUETOOTH;
                } else if (className.getClassName().equals("com.android.bluetooth.gatt.GattService")) {
                    msg.arg1 = SERVICE_IBLUETOOTHGATT;
                } else {
                    Log.e(TAG, "Unknown service disconnected: " + className.getClassName());
                    return;
                }
                mHandler.sendMessage(msg);
            }
        }

        private IBluetooth mBluetooth;
        private BluetoothServiceConnection mConnection = new BluetoothServiceConnection();

        private class BluetoothHandler extends Handler {
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case MESSAGE_GET_NAME_AND_ADDRESS: {
                        if ((mBluetooth == null) && (!mBinding)) {
                            Intent i = new Intent(IBluetooth.class.getName());
                            if (!doBind(i, mConnection,                                     // 执行doBind的时候，就会自动调用onServiceConnected
                                    Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT,
                                    UserHandle.CURRENT)) {
                                mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                            } else {
                                mBinding = true;
                            }
                        }
                        else {
                            Message saveMsg= mHandler.obtainMessage(MESSAGE_SAVE_NAME_AND_ADDRESS);
                            saveMsg.arg1 = 0;
                            if (mBluetooth != null) {
                                mHandler.sendMessage(saveMsg);
                            } else {
                                // if enable is also called to bind the service
                                // wait for MESSAGE_BLUETOOTH_SERVICE_CONNECTED
                                mHandler.sendMessageDelayed(saveMsg, TIMEOUT_SAVE_MS);
                            }
                        }
                    }
                    break;

                    case MESSAGE_SAVE_NAME_AND_ADDRESS: {
                        synchronized(mConnection) {
                            if (!mEnable && mBluetooth != null) {
                                try {
                                    mBluetooth.enable();
                                } catch (RemoteException e) {
                                    Log.e(TAG,"Unable to call enable()",e);
                                }
                            }
                        }
                        if (mBluetooth != null) waitForOnOff(true, false);
                        synchronized(mConnection) {
                            if (mBluetooth != null) {
                                String name =  null;
                                String address = null;
                                try {
                                    name =  mBluetooth.getName();
                                    address = mBluetooth.getAddress();
                                } catch (RemoteException re) {
                                    Log.e(TAG,"",re);
                                }

                                if (name != null && address != null) {
                                    storeNameAndAddress(name,address);
                                    if (mConnection.isGetNameAddressOnly()) {
                                        unbind = true;
                                    }
                                }

                                if (!mEnable) {
                                    try {
                                        mBluetooth.disable();
                                    } catch (RemoteException e) {
                                        Log.e(TAG,"Unable to call disable()",e);
                                    }
                                }
                            }
                            else {
                                // rebind service by Request GET NAME AND ADDRESS
                                // if service is unbinded by disable or
                                // MESSAGE_BLUETOOTH_SERVICE_CONNECTED is not received
                                Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                                mHandler.sendMessage(getMsg);
                            }
                        }
                        if (!mEnable && mBluetooth != null) waitForOnOff(false, true);
                        if (unbind) {
                            unbindAndFinish();
                        }
                        break;
                    }

                    case MESSAGE_ENABLE:
                        if (DBG) {
                            Log.d(TAG, "MESSAGE_ENABLE: mBluetooth = " + mBluetooth);
                        }
                        mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mEnable = true;
                        handleEnable(msg.arg1 == 1);
                        break;

                    case MESSAGE_REGISTER_ADAPTER:
                        {
                            IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                            boolean added = mCallbacks.register(callback);
                            Log.d(TAG,"Added callback: " +  (callback == null? "null": callback)  +":" +added );
                        }
                        break;

                    case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
                        {
                            IBinder service = (IBinder) msg.obj;
                            synchronized(mConnection) {
                                if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                                    mBluetoothGatt = IBluetoothGatt.Stub.asInterface(service);
                                    break;
                                } // else must be SERVICE_IBLUETOOTH

                                //Remove timeout
                                mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);

                                mBinding = false;
                                mBluetooth = IBluetooth.Stub.asInterface(service);

                                try {
                                    boolean enableHciSnoopLog = (Settings.Secure.getInt(mContentResolver,       // 查看是否打开Hci Snoop Log
                                                Settings.Secure.BLUETOOTH_HCI_LOG, 0) == 1);
                                    if (!mBluetooth.configHciSnoopLog(enableHciSnoopLog)) {
                                        Log.e(TAG,"IBluetooth.configHciSnoopLog return false");
                                    }
                                } catch (RemoteException e) {
                                    Log.e(TAG,"Unable to call configHciSnoopLog", e);
                                }

                                //Register callback object
                                try {
                                    mBluetooth.registerCallback(mBluetoothCallback);                // 注册Callback
                                } catch (RemoteException re) {
                                    Log.e(TAG, "Unable to register BluetoothCallback",re);
                                }
                                //Inform BluetoothAdapter instances that service is up
                                sendBluetoothServiceUpCallback();

                                if (mQuietEnable == false) {
                                    if(!mBluetooth.enable()) {
                                        Log.e(TAG,"IBluetooth.enable() returned false");
                                    }
                                }
                                else
                                {
                                    if(!mBluetooth.enableNoAutoConnect()) {
                                        Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
                                    }
                                }
                            }

                            if (!mEnable) {
                                waitForOnOff(true, false);
                                handleDisable();
                                waitForOnOff(false, false);
                            }
                        }
                }
            }
        }

        private final IBluetoothCallback mBluetoothCallback =  new IBluetoothCallback.Stub() {
            @Override
                public void onBluetoothStateChange(int prevState, int newState) throws RemoteException  {
                    Message msg = mHandler.obtainMessage(MESSAGE_BLUETOOTH_STATE_CHANGE,prevState,newState); //触发MESSAGE_BLUETOOTH_STATE_CHANGE
                    mHandler.sendMessage(msg);
                }
        };

        private void handleEnable(boolean quietMode) {
            if (!mQuietEnable) {
                if(!mBluetooth.enable()) {
                    Log.e(TAG,"IBluetooth.enable() returned false");
                }
            }
            else {
                if(!mBluetooth.enableNoAutoConnect()) {
                    Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
                }
            }
        }
    }
----------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        public class AdapterService extends Service {
            static {
                classInitNative();                                                              // 调用classInitNative
            }

            public void onCreate() {
                mBinder = new AdapterServiceBinder(this);
                mAdapterProperties = new AdapterProperties(this);
                mAdapterStateMachine =  AdapterState.make(this, mAdapterProperties);
                mJniCallbacks =  new JniCallbacks(mAdapterStateMachine, mAdapterProperties);
                initNative();                                                                   // 调用initNative 
                mNativeAvailable=true;
                mCallbacks = new RemoteCallbackList<IBluetoothCallback>();
                //Load the name and address
                getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);
                getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);
                mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
                mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);

                registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));
            }

            private static class AdapterServiceBinder extends IBluetooth.Stub {               // AdapterServiceBinder实现了IBluetooth接口
                private AdapterService mService;

                public AdapterServiceBinder(AdapterService svc) {
                    mService = svc;
                }

                public AdapterService getService() {
                    if (mService  != null && mService.isAvailable()) {
                        return mService;
                    }
                    return null;
                }

                public boolean enable() {
                    if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
                            (!Utils.checkCaller())) {
                        Log.w(TAG, "enable() - Not allowed for non-active user and non system user");
                        return false;
                    }

                    AdapterService service = getService();
                    if (service == null) return false;
                    return service.enable();
                }
            }
        }
    }
    ->  {
             public synchronized boolean enable(boolean quietMode) {
                 enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                         "Need BLUETOOTH ADMIN permission");
                 debugLog("enable() - Enable called with quiet mode status =  " + mQuietmode);
                 mQuietmode  = quietMode;
                 Message m = mAdapterStateMachine.obtainMessage(AdapterState.USER_TURN_ON);
                 mAdapterStateMachine.sendMessage(m);
                 return true;
             }
        }
----------------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        final class AdapterState extends StateMachine {
            public static AdapterState make(AdapterService service, AdapterProperties adapterProperties) {
                AdapterState as = new AdapterState(service, adapterProperties);
                as.start();
                return as;
            }

            private AdapterState(AdapterService service, AdapterProperties adapterProperties) {
                addState(mOnState);
                addState(mOffState);
                addState(mPendingCommandState);
                mAdapterService = service;
                mAdapterProperties = adapterProperties;
                setInitialState(mOffState);
            }
        }
    }
    ->  {
            private class OffState extends State {
                public boolean processMessage(Message msg) {
                    AdapterService adapterService = mAdapterService;

                    switch(msg.what) {
                        case USER_TURN_ON:
                            notifyAdapterStateChange(BluetoothAdapter.STATE_TURNING_ON);    // 更新property状态，调用onBluetoothStateChange
                            mPendingCommandState.setTurningOn(true);
                            transitionTo(mPendingCommandState);                             // 切换到PendingCommandState模式
                            sendMessageDelayed(START_TIMEOUT, START_TIMEOUT_DELAY);
                            adapterService.processStart();
                            break;
                    }
                }
            }
        }
----------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void processStart() {
            debugLog("processStart()");
            Class[] supportedProfileServices = Config.getSupportedProfiles();
            //Initialize data objects
            for (int i=0; i < supportedProfileServices.length;i++) {
                mProfileServicesState.put(supportedProfileServices[i].getName(),BluetoothAdapter.STATE_OFF);
            }
            mRemoteDevices = new RemoteDevices(this);
            mAdapterProperties.init(mRemoteDevices);

            if (DBG) {debugLog("processStart(): Make Bond State Machine");}
            mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);

            mJniCallbacks.init(mBondStateMachine,mRemoteDevices);

            //FIXME: Set static instance here???
            setAdapterService(this);

            //Start profile services
            if (!mProfilesStarted && supportedProfileServices.length >0) {
                //Startup all profile services
                setProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_ON);
            }else {
                if (DBG) {debugLog("processStart(): Profile Services alreay started");}
                mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.STARTED));     // 发送STARTED命令
            }
        }
    }
    ->  {
        ---------------------------------------------------------------------------------------------------------
            Config.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
            ->  {
                    private static final int[]  PROFILE_SERVICES_FLAG = {
                        R.bool.profile_supported_hs_hfp,
                        R.bool.profile_supported_a2dp,
                        R.bool.profile_supported_a2dp_sink,
                        R.bool.profile_supported_hid,
                        R.bool.profile_supported_hdp,
                        R.bool.profile_supported_pan,
                        R.bool.profile_supported_gatt,
                        R.bool.profile_supported_map,
                        R.bool.profile_supported_hfpclient,
                        R.bool.profile_supported_avrcp_controller,
                    };

                    private static Class[] SUPPORTED_PROFILES = new Class[0];

                    static void init(Context ctx) {
                        if (ctx == null) {
                            return;
                        }
                        Resources resources = ctx.getResources();
                        if (resources == null) {
                            return;
                        }
                        ArrayList<Class> profiles = new ArrayList<Class>(PROFILE_SERVICES.length);
                        for (int i=0; i < PROFILE_SERVICES_FLAG.length; i++) {
                            boolean supported = resources.getBoolean(PROFILE_SERVICES_FLAG[i]);
                            if (supported) {
                                Log.d(TAG, "Adding " + PROFILE_SERVICES[i].getSimpleName());
                                profiles.add(PROFILE_SERVICES[i]);
                            }
                        }
                        int totalProfiles = profiles.size();
                        SUPPORTED_PROFILES = new Class[totalProfiles];
                        profiles.toArray(SUPPORTED_PROFILES);
                    }

                    static Class[]  getSupportedProfiles() {
                        return SUPPORTED_PROFILES;
                    }
                }
                ->  {
                    ----------------------------------------------------------------------------------------------
                         config.xml (prj/rk3288/packages/apps/Bluetooth/res/values)
                         -> {
                                <resources>
                                     <bool name="profile_supported_a2dp">true</bool>
                                     <bool name="profile_supported_a2dp_sink">false</bool>
                                     <bool name="profile_supported_hdp">true</bool>
                                     <bool name="profile_supported_hs_hfp">true</bool>
                                     <bool name="profile_supported_hfpclient">false</bool>
                                     <bool name="profile_supported_hid">true</bool>
                                     <bool name="profile_supported_opp">true</bool>
                                     <bool name="profile_supported_pan">true</bool>
                                     <bool name="profile_supported_pbap">true</bool>
                                     <bool name="profile_supported_gatt">true</bool>
                                     <bool name="pbap_include_photos_in_vcard">false</bool>
                                     <bool name="pbap_use_profile_for_owner_vcard">true</bool>
                                     <bool name="profile_supported_map">true</bool>
                                     <bool name="profile_supported_avrcp_controller">false</bool>
                                </resources>
                            }
                    }
        }
---------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        private class PendingCommandState extends State {
            switch (msg.what) {
                case STARTED:   
                    //Enable
                    boolean ret = adapterService.enableNative();
                    if (!ret) {
                        Log.e(TAG, "Error while turning Bluetooth On");
                        notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                        transitionTo(mOffState);
                    } else {
                        sendMessageDelayed(ENABLE_TIMEOUT, ENABLE_TIMEOUT_DELAY);
                    }
                    break;
            }
        }
    }
---------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static JNINativeMethod sMethods[] = {
            {"classInitNative", "()V", (void *) classInitNative},
            {"initNative", "()Z", (void *) initNative},
            {"enableNative", "()Z",  (void*) enableNative},
        };
    }
---------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static void classInitNative(JNIEnv* env, jclass clazz) {
            char value[PROPERTY_VALUE_MAX];
            property_get("bluetooth.mock_stack", value, "");

            const char *id = (strcmp(value, "1")? BT_STACK_MODULE_ID : BT_STACK_TEST_MODULE_ID);

            char type[64];
            check_wifi_chip_type_string(type);
            if (!strncmp(type, "RTL", 3)) {
                ALOGD("%s, load %s.default.so", __func__, BT_STACK_RTK_MODULE_ID);
                err = hw_get_module(BT_STACK_RTK_MODULE_ID, (hw_module_t const**)&module);
            } else {
                ALOGD("%s, load %s.default.so", __func__, id);                              // bluetooth.default.so
                err = hw_get_module(id, (hw_module_t const**)&module);                      // 对应下面的HAL_MODULE_INFO_SYM
            }

            if (err == 0) {
                hw_device_t* abstraction;
                err = module->methods->open(module, id, &abstraction);                      // 对应下面的open_bluetooth_stack
                if (err == 0) {
                    bluetooth_module_t* btStack = (bluetooth_module_t *)abstraction;
                    sBluetoothInterface = btStack->get_bluetooth_interface();     // 获取蓝牙HAL控制接口, 对应bluetooth__get_bluetooth_interface
                } else {
                    ALOGE("Error while opening Bluetooth library");
                }
            } else {
                ALOGE("No Bluetooth Library found");
            }
        }

        static bt_callbacks_t sBluetoothCallbacks = {
            sizeof(sBluetoothCallbacks),
            adapter_state_change_callback,
            adapter_properties_callback,
            remote_device_properties_callback,
            device_found_callback,
            discovery_state_changed_callback,
            pin_request_callback,
            ssp_request_callback,
            bond_state_changed_callback,
            acl_state_changed_callback,
            callback_thread_event,
            dut_mode_recv_callback,

            le_test_mode_recv_callback,
            energy_info_recv_callback
        };

        static bool initNative(JNIEnv* env, jobject obj) {
            ALOGV("%s:",__FUNCTION__);

            sJniAdapterServiceObj = env->NewGlobalRef(obj);
            sJniCallbacksObj = env->NewGlobalRef(env->GetObjectField(obj, sJniCallbacksField));

            if (sBluetoothInterface) {
                int ret = sBluetoothInterface->init(&sBluetoothCallbacks);                  // 初始化蓝牙HAL控制接口, 调用init接口
                if (ret != BT_STATUS_SUCCESS) {
                    ALOGE("Error while setting the callbacks: %d\n", ret);
                    sBluetoothInterface = NULL;
                    return JNI_FALSE;
                }
                ret = sBluetoothInterface->set_os_callouts(&sBluetoothOsCallouts);
                if (ret != BT_STATUS_SUCCESS) {
                    ALOGE("Error while setting Bluetooth callouts: %d\n", ret);
                    sBluetoothInterface->cleanup();
                    sBluetoothInterface = NULL;
                    return JNI_FALSE;
                }

                if ( (sBluetoothSocketInterface = (btsock_interface_t *)
                            sBluetoothInterface->get_profile_interface(BT_PROFILE_SOCKETS_ID)) == NULL) {
                    ALOGE("Error getting socket interface");
                }

                if ( (sBluetoothMceInterface = (btmce_interface_t *)
                            sBluetoothInterface->get_profile_interface(BT_PROFILE_MAP_CLIENT_ID)) == NULL) {
                    ALOGE("Error getting mapclient interface");
                } else {
                    if ( (sBluetoothMceInterface->init(&sBluetoothMceCallbacks)) != BT_STATUS_SUCCESS) {
                        ALOGE("Failed to initialize Bluetooth MCE");
                        sBluetoothMceInterface = NULL;
                    }
                }

                return JNI_TRUE;
            }
            return JNI_FALSE;
        }

        static jboolean enableNative(JNIEnv* env, jobject obj) {
            int ret = sBluetoothInterface->enable();
            result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;                 // 使能蓝牙HAL控制接口，调用enable函数
            return result;
        }   
    }
---------------------------------------------------------------------------------------------------->
Bluetooth.h (z:\home\ballack\prj\rk3288\hardware\libhardware\include\hardware)
->  {
        #define BT_HARDWARE_MODULE_ID "bluetooth"
        #define BT_STACK_MODULE_ID "bluetooth"
        #define BT_STACK_TEST_MODULE_ID "bluetooth_test"
        #define BT_STACK_RTK_MODULE_ID "bluetooth_rtk"
    }
---------------------------------------------------------------------------------------------------->
Bluetooth.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        static const bt_interface_t bluetoothInterface = {
            sizeof(bluetoothInterface),
            init,
            enable,
            disable,
            enable_radio,
            disable_radio,
            cleanup,
            get_adapter_properties,
            get_adapter_property,
            set_adapter_property,
            get_remote_device_properties,
            get_remote_device_property,
            set_remote_device_property,
            get_remote_service_record,
            get_remote_services,
            start_discovery,
            cancel_discovery,
            create_bond,
            remove_bond,
            cancel_bond,
            get_connection_state,
            pin_reply,
            ssp_reply,
            get_profile_interface,
            dut_mode_configure,
            dut_mode_send,
        #if BLE_INCLUDED == TRUE
            le_test_mode,
        #else
            NULL,
        #endif
            config_hci_snoop_log,
            set_os_callouts,
            read_energy_info,
            get_fm_interface
        };

        static int init(bt_callbacks_t* callbacks )
        {
            ALOGI("init");

            /* sanity check */
            if (interface_ready() == TRUE)
                return BT_STATUS_DONE;

            /* store reference to user callbacks */
            bt_hal_cbacks = callbacks;

            /* add checks for individual callbacks ? */

            bt_utils_init();

            /* init btif */
            btif_init_bluetooth();                          // 初始化btif

            return BT_STATUS_SUCCESS;
        }

        static int enable( void )
        {
            ALOGI("enable");

            /* sanity check */
            if (interface_ready() == FALSE)
                return BT_STATUS_NOT_READY;

            return btif_enable_bluetooth();
        }

        const bt_interface_t* bluetooth__get_bluetooth_interface ()
        {
            /* fixme -- add property to disable bt interface ? */

            return &bluetoothInterface;
        }

        static int open_bluetooth_stack (const struct hw_module_t* module, char const* name,
                struct hw_device_t** abstraction)
        {
            UNUSED(name);

            bluetooth_device_t *stack = malloc(sizeof(bluetooth_device_t) );
            memset(stack, 0, sizeof(bluetooth_device_t) );
            stack->common.tag = HARDWARE_DEVICE_TAG;
            stack->common.version = 0;
            stack->common.module = (struct hw_module_t*)module;
            stack->common.close = close_bluetooth_stack;
            stack->get_bluetooth_interface = bluetooth__get_bluetooth_interface;
            *abstraction = (struct hw_device_t*)stack;
            return 0;
        }


        static struct hw_module_methods_t bt_stack_module_methods = {
            .open = open_bluetooth_stack,
        };

        struct hw_module_t HAL_MODULE_INFO_SYM = {
            .tag = HARDWARE_MODULE_TAG,
            .version_major = 1,
            .version_minor = 0,
            .id = BT_HARDWARE_MODULE_ID,
            .name = "Bluetooth Stack",
            .author = "The Android Open Source Project",
            .methods = &bt_stack_module_methods
        };
    }
------------------------------------------------------------------------------------------------------->
Btif_core.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        bt_status_t btif_init_bluetooth()
        {
            UINT8 status;
            btif_config_init();
            bte_main_boot_entry();                                          // bte主引导进入

            /* As part of the init, fetch the local BD ADDR */
            memset(&btif_local_bd_addr, 0, sizeof(bt_bdaddr_t));
            btif_fetch_local_bdaddr(&btif_local_bd_addr);

            /* start btif task */
            // BTIF task handler managing all messages being passed Bluetooth HAL and BTA.  // btif_task处理所有蓝牙HAL和BTA的消息
            status = GKI_create_task(btif_task, BTIF_TASK, BTIF_TASK_STR,
                    (UINT16 *) ((UINT8 *)btif_task_stack + BTIF_TASK_STACK_SIZE),
                    sizeof(btif_task_stack));

            if (status != GKI_SUCCESS)
                return BT_STATUS_FAIL;

            return BT_STATUS_SUCCESS;
        }

        static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
        {
            char val[256];
            uint8_t valid_bda = FALSE;
            int val_size = 0;
            const uint8_t null_bdaddr[BD_ADDR_LEN] = {0,0,0,0,0,0};

            {// cmy@2012-11-28: Get local bdaddr from vflash
                int vflash_fd = open("/dev/vflash", O_RDONLY);                  // 先从/dev/vflash读取蓝牙MAC
                if (vflash_fd > 0)
                {
                    char bd_addr[6] = {0};
                    BTIF_TRACE_DEBUG("Get local bdaddr from vflash");
                #define VFLASH_READ_BDA  0x01
                    if(ioctl(vflash_fd, VFLASH_READ_BDA, (unsigned long)bd_addr) >= 0
                            && memcmp(bd_addr, null_bdaddr, BD_ADDR_LEN) != 0)
                    {
                        local_addr->address[0] = bd_addr[5];
                        local_addr->address[1] = bd_addr[4];
                        local_addr->address[2] = bd_addr[3];
                        local_addr->address[3] = bd_addr[2];
                        local_addr->address[4] = bd_addr[1];
                        local_addr->address[5] = bd_addr[0];

                        local_addr->address[0] = local_addr->address[0] & 0xFE; // avoid multicast address
                        valid_bda = TRUE;
                        BTIF_TRACE_DEBUG("Got Factory BDA %02X:%02X:%02X:%02X:%02X:%02X",
                                local_addr->address[0], local_addr->address[1], local_addr->address[2],
                                local_addr->address[3], local_addr->address[4], local_addr->address[5]);
                    }
                    close(vflash_fd);
                }
            }

            /* Get local bdaddr storage path from property */
            if (!valid_bda && property_get(PROPERTY_BT_BDADDR_PATH, val, NULL))     // #define PROPERTY_BT_BDADDR_PATH   "ro.bt.bdaddr_path"
            {
                int addr_fd;

                BTIF_TRACE_DEBUG("local bdaddr is stored in %s", val);

                if ((addr_fd = open(val, O_RDONLY)) != -1)
                {
                    memset(val, 0, sizeof(val));
                    read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);
                    str2bd(val, local_addr);
                    /* If this is not a reserved/special bda, then use it */
                    if (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0)
                    {
                        valid_bda = TRUE;
                        BTIF_TRACE_DEBUG("Got Factory BDA %02X:%02X:%02X:%02X:%02X:%02X",
                                local_addr->address[0], local_addr->address[1], local_addr->address[2],
                                local_addr->address[3], local_addr->address[4], local_addr->address[5]);
                    }

                    close(addr_fd);
                }
            }

            if(!valid_bda)
            {
                val_size = sizeof(val);
                if(btif_config_get_str("Local", "Adapter", "Address", val, &val_size))
                {
                    str2bd(val, local_addr);
                    BTIF_TRACE_DEBUG("local bdaddr from bt_config.xml is  %s", val);
                    return;
                }
            }

            /* No factory BDADDR found. Look for previously generated random BDA */
            if ((!valid_bda) && \
                    (property_get(PERSIST_BDADDR_PROPERTY, val, NULL)))     // #define PERSIST_BDADDR_PROPERTY  "persist.service.bdroid.bdaddr"
            {
                str2bd(val, local_addr);
                valid_bda = TRUE;
                BTIF_TRACE_DEBUG("Got prior random BDA %02X:%02X:%02X:%02X:%02X:%02X",
                        local_addr->address[0], local_addr->address[1], local_addr->address[2],
                        local_addr->address[3], local_addr->address[4], local_addr->address[5]);
            }

            /* Generate new BDA if necessary */
            if (!valid_bda)
            {
                bdstr_t bdstr;
                /* Seed the random number generator */
                srand((unsigned int) (time(0)));

                /* No autogen BDA. Generate one now. */
                local_addr->address[0] = 0x22;
                local_addr->address[1] = 0x22;
                local_addr->address[2] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[3] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[4] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[5] = (uint8_t) ((rand() >> 8) & 0xFF);

                /* Convert to ascii, and store as a persistent property */
                bd2str(local_addr, &bdstr);

                BTIF_TRACE_DEBUG("No preset BDA. Generating BDA: %s for prop %s",
                        (char*)bdstr, PERSIST_BDADDR_PROPERTY);

                if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0)
                    BTIF_TRACE_ERROR("Failed to set random BDA in prop %s",PERSIST_BDADDR_PROPERTY);
            }

            //save the bd address to config file
            bdstr_t bdstr;
            bd2str(local_addr, &bdstr);
            val_size = sizeof(val);
            if (btif_config_get_str("Local", "Adapter", "Address", val, &val_size))
            {
                if (strcmp(bdstr, val) ==0)
                {
                    // BDA is already present in the config file.
                    return;
                }
            }
            btif_config_set_str("Local", "Adapter", "Address", bdstr);
            btif_config_save();
        }

        /*******************************************************************************
         **
         ** Function         btif_task
         **
         ** Description      BTIF task handler managing all messages being passed
         **                  Bluetooth HAL and BTA.
         **
         ** Returns          void
         **
         *******************************************************************************/

        static void btif_task(UINT32 params)
        {
            UINT16   event;
            BT_HDR   *p_msg;
            UNUSED(params);

            BTIF_TRACE_DEBUG("btif task starting");

            btif_associate_evt();

            for(;;)
            {
                /* wait for specified events */
                event = GKI_wait(0xFFFF, 0);

                /*
                 * Wait for the trigger to init chip and stack. This trigger will
                 * be received by btu_task once the UART is opened and ready
                 */
                if (event == BT_EVT_TRIGGER_STACK_INIT)                             // 处理btu_task发出来的BT_EVT_TRIGGER_STACK_INIT命令
                {
                    BTIF_TRACE_DEBUG("btif_task: received trigger stack init event");
#if (BLE_INCLUDED == TRUE)
                    btif_dm_load_ble_local_keys();
#endif
                    BTA_EnableBluetooth(bte_dm_evt);
                }

                /*
                 * Failed to initialize controller hardware, reset state and bring
                 * down all threads
                 */
                if (event == BT_EVT_HARDWARE_INIT_FAIL)
                {
                    BTIF_TRACE_DEBUG("btif_task: hardware init failed");
                    bte_main_disable();
                    btif_queue_release();
                    GKI_task_self_cleanup(BTIF_TASK);
                    bte_main_shutdown();
                    btif_dut_mode = 0;
                    btif_core_state = BTIF_CORE_STATE_DISABLED;
                    HAL_CBACK(bt_hal_cbacks,adapter_state_changed_cb,BT_STATE_OFF);
                    break;
                }

                if (event & EVENT_MASK(GKI_SHUTDOWN_EVT))
                    break;

                if(event & TASK_MBOX_1_EVT_MASK)
                {
                    while((p_msg = GKI_read_mbox(BTU_BTIF_MBOX)) != NULL)
                    {
                        BTIF_TRACE_VERBOSE("btif task fetched event %x", p_msg->event);

                        switch (p_msg->event)
                        {
                            case BT_EVT_CONTEXT_SWITCH_EVT:
                                btif_context_switched(p_msg);
                                break;
                            default:
                                BTIF_TRACE_ERROR("unhandled btif event (%d)", p_msg->event & BT_EVT_MASK);
                                break;
                        }

                        GKI_freebuf(p_msg);
                    }
                }
            }

            btif_disassociate_evt();

            BTIF_TRACE_DEBUG("btif task exiting");
        }

        bt_status_t btif_enable_bluetooth(void)
        {
            BTIF_TRACE_DEBUG("BTIF ENABLE BLUETOOTH");

            if (btif_core_state != BTIF_CORE_STATE_DISABLED)
            {
                ALOGD("not disabled\n");
                return BT_STATUS_DONE;
            }

            btif_core_state = BTIF_CORE_STATE_ENABLING;

            /* Create the GKI tasks and run them */
            bte_main_enable();

            return BT_STATUS_SUCCESS;
        }
    }
-------------------------------------------------------------------------------------------------------->
Bte_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\main)
->  {
        /******************************************************************************
         **
         ** Function         bte_main_boot_entry
         **
         ** Description      BTE MAIN API - Entry point for BTE chip/stack initialization
         **
         ** Returns          None
         **
         ******************************************************************************/
        void bte_main_boot_entry(void)
        {
            /* initialize OS */
            GKI_init();

            bte_main_in_hw_init();

            bte_load_conf(BTE_STACK_CONF_FILE);                             // 默认是"/etc/bluetooth/bt_stack.conf"
        #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))               
            bte_load_ble_conf(BTE_BLE_STACK_CONF_FILE);                     // 默认是"/etc/bluetooth/ble_stack.conf"
        #endif

        #if (BTTRC_INCLUDED == TRUE)
            /* Initialize trace feature */
            BTTRC_TraceInit(MAX_TRACE_RAM_SIZE, &BTE_TraceLogBuf[0], BTTRC_METHOD_RAM);
        #endif

            pthread_mutex_init(&cleanup_lock, NULL);

        }

        /******************************************************************************
         **
         ** Function         bte_main_in_hw_init
         **
         ** Description      Internal helper function for chip hardware init
         **
         ** Returns          None
         **
         ******************************************************************************/
        static void bte_main_in_hw_init(void)
        {
            if ( (bt_hc_if = (bt_hc_interface_t *) bt_hc_get_interface()) \                 // 获取hci控制接口
                    == NULL)
            {
                APPL_TRACE_ERROR("!!! Failed to get BtHostControllerInterface !!!");
            }

            memset(&preload_retry_cb, 0, sizeof(bt_preload_retry_cb_t));
        }

        void bte_main_enable()
        {
            APPL_TRACE_DEBUG("%s", __FUNCTION__);

            /* Initialize BTE control block */
            BTE_Init();                                                         // 初始化BTE控制块

            lpm_enabled = FALSE;

            GKI_create_task((TASKPTR)btu_task, BTU_TASK, BTE_BTU_TASK_STR,
                    (UINT16 *) ((UINT8 *)bte_btu_stack + BTE_BTU_STACK_SIZE),
                    sizeof(bte_btu_stack));

            bte_hci_enable();                                                   // BTE hci使能

            GKI_run();
        }
    }
-------------------------------------------------------------------------------------------------------->
Btu_init.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\stack\btu)
->  {
        #define BTU_DEFAULT_DATA_SIZE (0x2a0)
        #define HCI_DATA_PREAMBLE_SIZE  4

        /*****************************************************************************
         **
         ** Function         BTE_Init
         **
         ** Description      Initializes the BTU control block.
         **
         **                  NOTE: Must be called before creating any tasks
         **                      (RPC, BTU, HCIT, APPL, etc.)
         **
         ** Returns          void
         **
         ******************************************************************************/
        void BTE_Init(void)
        {
            int i = 0;

            memset (&btu_cb, 0, sizeof (tBTU_CB));
            btu_cb.hcit_acl_pkt_size = BTU_DEFAULT_DATA_SIZE + HCI_DATA_PREAMBLE_SIZE;
        #if (BLE_INCLUDED == TRUE)
            btu_cb.hcit_ble_acl_pkt_size = BTU_DEFAULT_BLE_DATA_SIZE + HCI_DATA_PREAMBLE_SIZE;
        #endif
            btu_cb.trace_level = HCI_INITIAL_TRACE_LEVEL;

            for ( i = 0; i < BTU_MAX_LOCAL_CTRLS; i++ ) /* include BR/EDR */
                btu_cb.hci_cmd_cb[i].cmd_window = 1;
        }
    }
-------------------------------------------------------------------------------------------------------->
Btu_task.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\stack\btu)
->  {
        /*******************************************************************************
         **
         ** Function         btu_task
         **
         ** Description      This is the main task of the Bluetooth Upper Layers unit.
         **                  It sits in a loop waiting for messages, and dispatches them
         **                  to the appropiate handlers.
         **
         ** Returns          should never return
         **
         *******************************************************************************/
        BTU_API UINT32 btu_task (UINT32 param) {
            btu_init_core();

            /* Initialize any optional stack components */
            BTE_InitStack();

        #if (defined(BTU_BTA_INCLUDED) && BTU_BTA_INCLUDED == TRUE)
            bta_sys_init();
        #endif

            /* Send a startup evt message to BTIF_TASK to kickstart the init procedure */
            GKI_send_event(BTIF_TASK, BT_EVT_TRIGGER_STACK_INIT);           // 这里就会向BTIF_TASK发送BT_EVT_TRIGGER_STACK_INIT

            prctl(PR_SET_NAME, (unsigned long)"BTU TASK", 0, 0, 0);

            raise_priority_a2dp(TASK_HIGH_BTU);                             // 提高A2DP的优先级， 这里有时间继续研究！！

            /* Wait for, and process, events */
            for (;;) {
                // ...
                
                #if (defined(BTU_BTA_INCLUDED) && BTU_BTA_INCLUDED == TRUE)
                if (event & TASK_MBOX_2_EVT_MASK)
                {
                    while ((p_msg = (BT_HDR *) GKI_read_mbox(TASK_MBOX_2)) != NULL)         // 这里就处理下面bta_sys_sendmsg发出的消息
                    {
                        bta_sys_event(p_msg);
                    }
                }

                if (event & TIMER_1_EVT_MASK)
                {
                    bta_sys_timer_update();
                }
                #endif
                
                // ...
            }
        }
    }
-----------------------------------------------------------------------------------------------
Btu_init.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\stack\btu)
->  {
        void btu_init_core(void)
        {
            /* Initialize the mandatory core stack components */
            btm_init();

            l2c_init();

            sdp_init();

        #if BLE_INCLUDED == TRUE
            gatt_init();
        #if (defined(SMP_INCLUDED) && SMP_INCLUDED == TRUE)
            SMP_Init();
        #endif
            btm_ble_init();
        #endif
        }
    }
----------------------------------------------------------------------------------------------------------
Bta_sys_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        static const tBTA_SYS_REG bta_sys_hw_reg =
        {
            bta_sys_sm_execute,
            NULL
        };

        /*******************************************************************************
         **
         ** Function         bta_sys_init
         **
         ** Description      BTA initialization; called from task initialization.
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BTA_API void bta_sys_init(void)
        {
            memset(&bta_sys_cb, 0, sizeof(tBTA_SYS_CB));
            ptim_init(&bta_sys_cb.ptim_cb, BTA_SYS_TIMER_PERIOD, p_bta_sys_cfg->timer);
            bta_sys_cb.task_id = GKI_get_taskid();
            appl_trace_level = p_bta_sys_cfg->trace_level;

            /* register BTA SYS message handler */
            bta_sys_register( BTA_ID_SYS,  &bta_sys_hw_reg);                // 注册BTA_ID_SYS的处理函数 

            /* register for BTM notifications */
            BTM_RegisterForDeviceStatusNotif ((tBTM_DEV_STATUS_CB*)&bta_sys_hw_btm_cback );

        #if( defined BTA_AR_INCLUDED ) && (BTA_AR_INCLUDED == TRUE)
            bta_ar_init();
        #endif
        }
    }
---------------------------------------------------------------------------------------------------------->
btu_task向BTIF_TASK, 即btif_task发送BT_EVT_TRIGGER_STACK_INIT之后，调用BTA_EnableBluetooth(bte_dm_evt);

Bta_sys.h (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)	
->  {
        /* registration structure */
        typedef struct
        {
            tBTA_SYS_EVT_HDLR   *evt_hdlr;
            tBTA_SYS_DISABLE    *disable;
        } tBTA_SYS_REG;
    }
---------------------------------------------------------------------------------------
Bta_dm_api.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\dm)
->  {
        static const tBTA_SYS_REG bta_dm_reg =
        {
            bta_dm_sm_execute,
            bta_dm_sm_disable
        };

        static const tBTA_SYS_REG bta_dm_search_reg =
        {
            bta_dm_search_sm_execute,
            bta_dm_search_sm_disable
        };
    
        /*******************************************************************************
         **
         ** Function         BTA_EnableBluetooth
         **
         ** Description      Enables bluetooth service.  This function must be
         **                  called before any other functions in the BTA API are called.
         **
         **
         ** Returns          tBTA_STATUS
         **
         *******************************************************************************/
        tBTA_STATUS BTA_EnableBluetooth(tBTA_DM_SEC_CBACK *p_cback)
        {
            tBTA_DM_API_ENABLE    *p_msg;

            /* Bluetooth disabling is in progress */
            if (bta_dm_cb.disabling)
                return BTA_FAILURE;

            memset(&bta_dm_cb, 0, sizeof(bta_dm_cb));

            bta_sys_register (BTA_ID_DM, &bta_dm_reg );                     // 注册BTA_ID_DM处理函数
            bta_sys_register (BTA_ID_DM_SEARCH, &bta_dm_search_reg );       // 注册BTA_ID_DM_SEARCH处理函数

            /* if UUID list is not provided as static data */
            bta_sys_eir_register(bta_dm_eir_update_uuid);

            if ((p_msg = (tBTA_DM_API_ENABLE *) GKI_getbuf(sizeof(tBTA_DM_API_ENABLE))) != NULL)
            {
                p_msg->hdr.event = BTA_DM_API_ENABLE_EVT;
                p_msg->p_sec_cback = p_cback;
                bta_sys_sendmsg(p_msg);                         // 发送BTA_DM_API_ENABLE_EVT消息！！
                return BTA_SUCCESS;
            }
            return BTA_FAILURE;
        }
    }
----------------------------------------------------------------------------------------------------------
Bta_sys.h (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /* Calculate start of event enumeration; id is top 8 bits of event */
        #define BTA_SYS_EVT_START(id)       ((id) << 8)
    }
----------------------------------------------------------------------------------------------------------
Bta_dm_int.h (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\dm)
->  {
        enum
        {
            /* device manager local device API events */
            BTA_DM_API_ENABLE_EVT = BTA_SYS_EVT_START(BTA_ID_DM),               // BTA_DM_API_ENABLE_EVT其实是BTA_ID_DM左移8位得到的值
        }
    }
---------------------------------------------------------------------------------------------------------->
Bta_sys_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /*******************************************************************************
         **
         ** Function         bta_sys_register
         **
         ** Description      Called by other BTA subsystems to register their event
         **                  handler.
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        void bta_sys_register(UINT8 id, const tBTA_SYS_REG *p_reg)
        {
            bta_sys_cb.reg[id] = (tBTA_SYS_REG *) p_reg;
            bta_sys_cb.is_reg[id] = TRUE;
        }

        /*******************************************************************************
         **
         ** Function         bta_sys_sendmsg
         **
         ** Description      Send a GKI message to BTA.  This function is designed to
         **                  optimize sending of messages to BTA.  It is called by BTA
         **                  API functions and call-in functions.
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        void bta_sys_sendmsg(void *p_msg)
        {
            GKI_send_msg(bta_sys_cb.task_id, p_bta_sys_cfg->mbox, p_msg);       // 从下面可以看到是往BTA_MBOX发消息
        }
    }
---------------------------------------------------------------------------------------------------------->
Bta_sys_cfg.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /* GKI task mailbox for BTA. */
        #ifndef BTA_MBOX
        #define BTA_MBOX                    TASK_MBOX_2                         // 可以看到BTA_MBOX就是TASK_MBOX_2
        #endif

        const tBTA_SYS_CFG bta_sys_cfg =
        {
            BTA_MBOX_EVT,               /* GKI mailbox event */
            BTA_MBOX,                   /* GKI mailbox id */
            BTA_TIMER,                  /* GKI timer id */
            APPL_INITIAL_TRACE_LEVEL    /* initial trace level */
        };

        tBTA_SYS_CFG *p_bta_sys_cfg = (tBTA_SYS_CFG *)&bta_sys_cfg;
    }
----------------------------------------------------------------------------------------------------------
由上面可以知道， 最后是由bta_sys_event来处理BTA_DM_API_ENABLE_EVT消息：

Bta_sys_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /*******************************************************************************
         **
         ** Function         bta_sys_event
         **
         ** Description      BTA event handler; called from task event handler.
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BTA_API void bta_sys_event(BT_HDR *p_msg)
        {
            UINT8       id;
            BOOLEAN     freebuf = TRUE;

            APPL_TRACE_EVENT("BTA got event 0x%x", p_msg->event);

            /* get subsystem id from event */
            id = (UINT8) (p_msg->event >> 8);                               // 右移8位，得到真正的id, 
                                                                            // 比如上面的BTA_DM_API_ENABLE_EVT, 右移8位后，变成BTA_ID_DM了

            /* verify id and call subsystem event handler */
            if ((id < BTA_ID_MAX) && (bta_sys_cb.reg[id] != NULL))
            {
                freebuf = (*bta_sys_cb.reg[id]->evt_hdlr)(p_msg);           // 所以处理函数就是bta_dm_reg的bta_dm_sm_execute, 这个函数后面分析
            }
            else
            {
                APPL_TRACE_WARNING("BTA got unregistered event id %d", id);
            }

            if (freebuf)
            {
                GKI_freebuf(p_msg);
            }

        }
    }
-----------------------------------------------------------------------------------------------------------
继续上面的bte_hci_enable：

Bte_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\main)
->  {
        static void bte_hci_enable(void)
        {
            APPL_TRACE_DEBUG("%s", __FUNCTION__);

            preload_start_wait_timer();

            if (bt_hc_if)
            {
                int result = bt_hc_if->init(&hc_callbacks, btif_local_bd_addr.address);
                APPL_TRACE_EVENT("libbt-hci init returns %d", result);

                assert(result == BT_HC_STATUS_SUCCESS);

                if (hci_logging_enabled == TRUE || hci_logging_config == TRUE)
                    bt_hc_if->logging(BT_HC_LOGGING_ON, hci_logfile, hci_save_log);

#if (defined (BT_CLEAN_TURN_ON_DISABLED) && BT_CLEAN_TURN_ON_DISABLED == TRUE)
                APPL_TRACE_DEBUG("%s  Not Turninig Off the BT before Turninig ON", __FUNCTION__);

                /* Do not power off the chip before powering on  if BT_CLEAN_TURN_ON_DISABLED flag
                   is defined and set to TRUE to avoid below mentioned issue.

                   Wingray kernel driver maintains a combined  counter to keep track of
                   BT-Wifi state. Invoking  set_power(BT_HC_CHIP_PWR_OFF) when the BT is already
                   in OFF state causes this counter to be incorrectly decremented and results in undesired
                   behavior of the chip.

                   This is only a workaround and when the issue is fixed in the kernel this work around
                   should be removed. */
#else
                /* toggle chip power to ensure we will reset chip in case
                   a previous stack shutdown wasn't completed gracefully */
                bt_hc_if->set_power(BT_HC_CHIP_PWR_OFF);
#endif
                bt_hc_if->set_power(BT_HC_CHIP_PWR_ON);

                bt_hc_if->preload(NULL);
            }
        }
    }
----------------------------------------------------------------------------------------------------------->
Bt_hci_bdroid.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        static const bt_hc_interface_t bluetoothHCLibInterface = {
            sizeof(bt_hc_interface_t),
            init,
            set_power,
            lpm,
            preload,
            postload,
            transmit_buf,
            logging,
            cleanup,
            tx_hc_cmd,
        };

        /*******************************************************************************
         **
         ** Function        bt_hc_get_interface
         **
         ** Description     Caller calls this function to get API instance
         **
         ** Returns         API table
         **
         *******************************************************************************/
        const bt_hc_interface_t *bt_hc_get_interface(void)
        {
            return &bluetoothHCLibInterface;
        }

        static int init(const bt_hc_callbacks_t* p_cb, unsigned char *local_bdaddr)
        {
            vendor_open(local_bdaddr);

            p_hci_if = &hci_h4_func_table;
            p_hci_if->init();
`
            // Set prio here and let hci worker thread inherit prio
            // remove once new thread api (thread_set_priority() ?)
            // can switch prio
            raise_priority_a2dp(TASK_HIGH_HCI_WORKER);                          // 这里又是提高A2DP优先级？ 
        }

        /** Chip power control */
        static void set_power(bt_hc_chip_power_state_t state)
        {
            int pwr_state;

            BTHCDBG("set_power %d", state);

            /* Calling vendor-specific part */
            pwr_state = (state == BT_HC_CHIP_PWR_ON) ? BT_VND_PWR_ON : BT_VND_PWR_OFF;

            vendor_send_command(BT_VND_OP_POWER_CTRL, &pwr_state);
        }

        /** Called prior to stack initialization */
        static void preload(UNUSED_ATTR TRANSAC transac) {
            thread_post(hc_cb.worker_thread, event_preload, NULL);
        }
        ->  {
                static void event_preload(UNUSED_ATTR void *context) {
                    userial_open(USERIAL_PORT_1);
                    vendor_send_command(BT_VND_OP_FW_CFG, NULL);
                }
            }
    }
------------------------------------------------------------------------------------------------------->
Vendor.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
        static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";

        static const bt_vendor_callbacks_t vendor_callbacks = {
            sizeof(vendor_callbacks),
            firmware_config_cb,
            sco_config_cb,
            low_power_mode_cb,
            sco_audiostate_cb,
            buffer_alloc,
            buffer_free,
            transmit_cb,
            epilog_cb
        };

        bool vendor_open(const uint8_t *local_bdaddr) {
            strcpy(vendor_so, VENDOR_LIBRARY_NAME);
            ALOGD("%s load %s", __func__, vendor_so);

            lib_handle = dlopen(vendor_so, RTLD_NOW);

            vendor_interface = (bt_vendor_interface_t *)dlsym(lib_handle, VENDOR_LIBRARY_SYMBOL_NAME);
            if (!vendor_interface) {
                ALOGE("%s unable to find symbol %s in %s: %s", __func__, VENDOR_LIBRARY_SYMBOL_NAME, vendor_so, dlerror());
                goto error;
            }

            int status = vendor_interface->init(&vendor_callbacks, (unsigned char *)local_bdaddr);
            if (status) {
                ALOGE("%s unable to initialize vendor library: %d", __func__, status);
                goto error;
            }

            return true;
        }       

        int vendor_send_command(bt_vendor_opcode_t opcode, void *param) {
            return vendor_interface->op(opcode, param);
        }
    }
---------------------------------------------------------------------------------------------------------->
Bt_vendor_brcm.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        // Entry point of DLib
        const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
            sizeof(bt_vendor_interface_t),
            init,
            op,
            cleanup
        };
        
        static int init(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr)
        {
        #if (VENDOR_LIB_RUNTIME_TUNING_ENABLED == TRUE)
            ALOGW("*****************************************************************");
            ALOGW("*****************************************************************");
            ALOGW("** Warning - BT Vendor Lib is loaded in debug tuning mode!");
            ALOGW("**");
            ALOGW("** If this is not intentional, rebuild libbt-vendor.so ");
            ALOGW("** with VENDOR_LIB_RUNTIME_TUNING_ENABLED=FALSE and ");
            ALOGW("** check if any run-time tuning parameters needed to be");
            ALOGW("** carried to the build-time configuration accordingly.");
            ALOGW("*****************************************************************");
            ALOGW("*****************************************************************");
        #endif

            userial_vendor_init();
            upio_init();

            vnd_load_conf(VENDOR_LIB_CONF_FILE);                        // 默认是"/etc/bluetooth/bt_vendor.conf", 解析并执行相应函数

            /* store reference to user callbacks */
            bt_vendor_cbacks = (bt_vendor_callbacks_t *) p_cb;          // 保存回调, 即vendor_callbacks

            /* This is handed over from the stack */
            memcpy(vnd_local_bd_addr, local_bdaddr, 6);

            return 0;
        }

        static int op(bt_vendor_opcode_t opcode, void *param)
        {
            int retval = 0;

            BTVNDDBG("op for %d", opcode);

            switch(opcode)
            {
                case BT_VND_OP_POWER_CTRL:
                    {
                        int *state = (int *) param;
                        if (*state == BT_VND_PWR_OFF)
                            upio_set_bluetooth_power(UPIO_BT_POWER_OFF);
                        else if (*state == BT_VND_PWR_ON)
                        {
                            upio_set_bluetooth_power(UPIO_BT_POWER_ON);
                            BTVNDDBG("Delay for a while after BT power on");
                            usleep(200000);

                        }
                    }
                    break;

                // Must call fwcfg_cb to notify the stack of the completion of vendor specific initialization once it has been done.
                case BT_VND_OP_FW_CFG:
                    {
                        hw_config_start();
                    }
                    break;

                case BT_VND_OP_USERIAL_OPEN:
                    {
                        int (*fd_array)[] = (int (*)[]) param;
                        int fd, idx;
                        fd = userial_vendor_open((tUSERIAL_CFG *) &userial_init_cfg);
                        if (fd != -1)
                        {
                            for (idx=0; idx < CH_MAX; idx++)
                                (*fd_array)[idx] = fd;

                            retval = 1;
                        }
                        /* retval contains numbers of open fd of HCI channels */
                    }
                    break;
            }
        }
    }
-------------------------------------------------------------------------------------------------->
Userial_vendor.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        void userial_vendor_init(void)
        {
            vnd_userial.fd = -1;
            snprintf(vnd_userial.port_name, VND_PORT_NAME_MAXLEN, "%s", \
                    BLUETOOTH_UART_DEVICE_PORT);                       // 默认是"/dev/ttyO1", BLUETOOTH_UART_DEVICE_PORT会在vnd_rk30sdk.txt定义
        }

        int userial_set_port(char *p_conf_name, char *p_conf_value, int param)
        {
            strcpy(vnd_userial.port_name, p_conf_value);

            return 0;
        }

        int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param)
        {

            strcpy(fw_patchfile_path, p_conf_value);

            return 0;
        }
    }
------------------------------------------------------------------------------------------
Android.mk (/home/ballack/prj/rk3288/device/common/bluetooth/libbt/)
->  {
        include $(LOCAL_PATH)/vnd_buildcfg.mk
    }
    ->  {
            vnd_buildcfg.mk
            ->  {
                    SRC := $(call my-dir)/include/vnd_rk30sdk.txt
                }
        }
--------------------------------------------------------------------------------------------
vnd_rk30sdk.txt (/home/ballack/prj/rk3288/device/common/bluetooth/libbt/include)
->  {
        BLUETOOTH_UART_DEVICE_PORT = "/dev/ttyS0"
        FW_PATCHFILE_LOCATION = "/vendor/firmware/"
        UART_TARGET_BAUD_RATE = 1500000
        LPM_IDLE_TIMEOUT_MULTIPLE = 5
        BTVND_DBG = FALSE
        BTHW_DBG = TRUE
        VNDUSERIAL_DBG = FALSE
        UPIO_DBG = FALSE
        BT_WAKE_VIA_PROC = TRUE
        SCO_PCM_ROUTING = 0
        SCO_PCM_IF_CLOCK_RATE = 1
        SCO_PCM_IF_FRAME_TYPE = 0
        SCO_PCM_IF_SYNC_MODE = 1
        SCO_PCM_IF_CLOCK_MODE = 1
        PCM_DATA_FMT_SHIFT_MODE = 0
        PCM_DATA_FMT_FILL_BITS = 0
        PCM_DATA_FMT_FILL_METHOD = 0
        PCM_DATA_FMT_FILL_NUM = 0
        PCM_DATA_FMT_JUSTIFY_MODE = 0
    }
----------------------------------------------------------------------------------------------------->
Conf.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        static const conf_entry_t conf_table[] = {
            {"UartPort", userial_set_port, 0},
            {"FwPatchFilePath", hw_set_patch_file_path, 0},
            {"FwPatchFileName", hw_set_patch_file_name, 0},
        #if (VENDOR_LIB_RUNTIME_TUNING_ENABLED == TRUE)
            {"FwPatchSettlementDelay", hw_set_patch_settlement_delay, 0},
        #endif
            {"AP6476_PCM2_Setup", get_pcm2_settings, 0 },
            {(const char *) NULL, NULL, 0}
        };

        void vnd_load_conf(const char *p_path)
        {
            if ((p_file = fopen(p_path, "r")) != NULL)
            {
                p_entry = (conf_entry_t *)conf_table;

                while (p_entry->conf_entry != NULL)
                {
                    // 从bt_vendor.conf中读取配置和conf_table中匹配的name, 并执行对应的函数
                    if (strcmp(p_entry->conf_entry, (const char *)p_name) == 0)     
                    {
                        p_entry->p_action(p_name, p_value, p_entry->param);
                        break;
                    }

                    p_entry++;
                }
            }
        }

        // bt_vendor.conf实例：
        //    # UART device port where Bluetooth controller is attached
        //        UartPort = /dev/ttyS0

        //    # Firmware patch file location
        //        FwPatchFilePath = /vendor/firmware/
    }

--------------------------------------------------------------------------------------------------------->
Upio.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        // 可以看到这个函数  其实就是做了echo 1 > /sys/class/rfkill/rfkill%d/state的动作
        int upio_set_bluetooth_power(int on)
        {
            int sz;
            int fd = -1;
            int ret = -1;
            char buffer = '0';

            switch(on)
            {
                case UPIO_BT_POWER_OFF:
                    buffer = '0';
                    break;

                case UPIO_BT_POWER_ON:
                    buffer = '1';
                    break;
            }

            if (is_emulator_context())
            {
                /* if new value is same as current, return -1 */
                if (bt_emul_enable == on)
                    return ret;

                UPIODBG("set_bluetooth_power [emul] %d", on);

                bt_emul_enable = on;
                return 0;
            }

            /* check if we have rfkill interface */
            if (is_rfkill_disabled())
                return 0;

            if (rfkill_id == -1)
            {
                if (init_rfkill())
                    return ret;
            }

            // 找到/sys/class/rfkill/rfkill%d/type是bluebooth的， 然后打开"/sys/class/rfkill/rfkill%d/state"
            fd = open(rfkill_state_path, O_WRONLY);                             

            if (fd < 0)
            {
                ALOGE("set_bluetooth_power : open(%s) for write failed: %s (%d)",
                        rfkill_state_path, strerror(errno), errno);
                return ret;
            }

            sz = write(fd, &buffer, 1);

            if (sz < 0) {
                ALOGE("set_bluetooth_power : write(%s) failed: %s (%d)",
                        rfkill_state_path, strerror(errno),errno);
            }
            else {
                ret = 0;
                ALOGD("Delay 500ms for bluetooth power up");
                usleep(500*1000);
            }

            if (fd >= 0)
                close(fd);

            return ret;
        }
    }
--------------------------------------------------------------------------------------------------------------------->
继续preload的处理：

Userial.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        bool userial_open(userial_port_t port) {       
            int fd_array[CH_MAX];
            for (int i = 0; i < CH_MAX; i++)
                fd_array[i] = -1;

            int num_ports = vendor_send_command(BT_VND_OP_USERIAL_OPEN, &fd_array);

            userial_cb.fd = fd_array[0];
            userial_cb.port = port;
        }
    }
--------------------------------------------------------------------------------------------------------------------
Bt_vendor_brcm.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        static const tUSERIAL_CFG userial_init_cfg =
        {
            (USERIAL_DATABITS_8 | USERIAL_PARITY_NONE | USERIAL_STOPBITS_1),
            USERIAL_BAUD_115200
        };

        int userial_vendor_open(tUSERIAL_CFG *p_cfg)
        {
            uint32_t baud;
            uint8_t data_bits;
            uint16_t parity;
            uint8_t stop_bits;

            vnd_userial.fd = -1;

            if (!userial_to_tcio_baud(p_cfg->baud, &baud))
            {
                return -1;
            }

            if(p_cfg->fmt & USERIAL_DATABITS_8)
                data_bits = CS8;
            else if(p_cfg->fmt & USERIAL_DATABITS_7)
                data_bits = CS7;
            else if(p_cfg->fmt & USERIAL_DATABITS_6)
                data_bits = CS6;
            else if(p_cfg->fmt & USERIAL_DATABITS_5)
                data_bits = CS5;
            else
            {
                ALOGE("userial vendor open: unsupported data bits");
                return -1;
            }

            if(p_cfg->fmt & USERIAL_PARITY_NONE)
                parity = 0;
            else if(p_cfg->fmt & USERIAL_PARITY_EVEN)
                parity = PARENB;
            else if(p_cfg->fmt & USERIAL_PARITY_ODD)
                parity = (PARENB | PARODD);
            else
            {
                ALOGE("userial vendor open: unsupported parity bit mode");
                return -1;
            }

            if(p_cfg->fmt & USERIAL_STOPBITS_1)
                stop_bits = 0;
            else if(p_cfg->fmt & USERIAL_STOPBITS_2)
                stop_bits = CSTOPB;
            else
            {
                ALOGE("userial vendor open: unsupported stop bits");
                return -1;
            }

            ALOGI("userial vendor open: opening %s", vnd_userial.port_name);

            if ((vnd_userial.fd = open(vnd_userial.port_name, O_RDWR)) == -1)
            {
                ALOGE("userial vendor open: unable to open %s", vnd_userial.port_name);
                return -1;
            }

            tcflush(vnd_userial.fd, TCIOFLUSH);

            tcgetattr(vnd_userial.fd, &vnd_userial.termios);
            cfmakeraw(&vnd_userial.termios);
            vnd_userial.termios.c_cflag |= (CRTSCTS | stop_bits);
            tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
            tcflush(vnd_userial.fd, TCIOFLUSH);

            tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
            tcflush(vnd_userial.fd, TCIOFLUSH);
            tcflush(vnd_userial.fd, TCIOFLUSH);

            /* set input/output baudrate */
            cfsetospeed(&vnd_userial.termios, baud);
            cfsetispeed(&vnd_userial.termios, baud);
            tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);

#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
            userial_ioctl_init_bt_wake(vnd_userial.fd);
#endif

            ALOGI("device fd = %d open", vnd_userial.fd);

            return vnd_userial.fd;
        }
    }
-------------------------------------------------------------------------------------------------------------------->
userial_open处理完后继续BT_VND_OP_FW_CFG的处理：

Hardware.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        void hw_config_start(void) {
            /* Start from sending HCI_RESET */

            if (bt_vendor_cbacks)
            {
                p_buf = (HC_BT_HDR *) bt_vendor_cbacks->alloc(BT_HC_HDR_SIZE + \
                        HCI_CMD_PREAMBLE_SIZE);
            }

            if (p_buf)
            {
                p_buf->event = MSG_STACK_TO_HC_HCI_CMD;     // #define MSG_STACK_TO_HC_HCI_CMD  0x2000 /* eq. BT_EVT_TO_LM_HCI_CMD */
                p_buf->offset = 0;
                p_buf->layer_specific = 0;
                p_buf->len = HCI_CMD_PREAMBLE_SIZE;

                p = (uint8_t *) (p_buf + 1);
                UINT16_TO_STREAM(p, HCI_RESET);
                *p = 0; /* parameter length */

                hw_cfg_cb.state = HW_CFG_START;

                bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);   // #define HCI_RESET  0x0C03
            }
        }
    }
------------------------------------------------------------------------------------------------
继续上面的bta_dm_sm_execute函数分析 :

Bta_dm_api.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\dm)
->  {
        /*******************************************************************************
         **
         ** Function         bta_dm_sm_execute
         **
         ** Description      State machine event handling function for DM
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BOOLEAN bta_dm_sm_execute(BT_HDR *p_msg)
        {
            UINT16  event = p_msg->event & 0x00ff;                  // 因为BTA_DM_API_ENABLE_EVT是BTA_ID_DM左移8位得到，所以&0xff，其实就是0

            APPL_TRACE_EVENT("bta_dm_sm_execute event:0x%x", event);

            /* execute action functions */
            if(event < BTA_DM_NUM_ACTIONS)
            {
                (*bta_dm_action[event])( (tBTA_DM_MSG*) p_msg);     // 所以调用的就是下面的bta_dm_enable
            }

            return TRUE;
        }
    }
------------------------------------------------------------------------------------------------
Bta_dm_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\dm)
->  {
        /* action function list */
        const tBTA_DM_ACTION bta_dm_action[] =
        {

            /* device manager local device API events */
            bta_dm_enable,            /* 0  BTA_DM_API_ENABLE_EVT */
            bta_dm_disable,           /* 1  BTA_DM_API_DISABLE_EVT */
            bta_dm_set_dev_name,      /* 2  BTA_DM_API_SET_NAME_EVT */
            bta_dm_set_visibility,    /* 3  BTA_DM_API_SET_VISIBILITY_EVT */
            bta_dm_set_afhchannels,   /* 4  BTA_DM_API_SET_AFH_CHANNELS_EVT */
            bta_dm_signal_strength,   /* 5  BTA_API_DM_SIG_STRENGTH_EVT */
            bta_dm_vendor_spec_command,/* 6  BTA_DM_API_VENDOR_SPECIFIC_COMMAND_EVT */
            bta_dm_tx_inqpower,       /* 7  BTA_DM_API_SIG_STRENGTH_EVT */
            bta_dm_acl_change,        /* 8  BTA_DM_ACL_CHANGE_EVT */
            bta_dm_add_device,        /* 9  BTA_DM_API_ADD_DEVICE_EVT */
            bta_dm_close_acl,         /* 10 BTA_DM_API_ADD_DEVICE_EVT */

            /* security API events */
            bta_dm_bond,              /* 11  BTA_DM_API_BOND_EVT */
            bta_dm_bond_cancel,       /* 12  BTA_DM_API_BOND_CANCEL_EVT */
            bta_dm_pin_reply,         /* 13 BTA_DM_API_PIN_REPLY_EVT */
            bta_dm_link_policy,       /* 14 BTA_DM_API_LINK_POLICY_EVT */
            bta_dm_auth_reply,        /* 15 BTA_DM_API_AUTH_REPLY_EVT */

            /* power manger events */
            bta_dm_pm_btm_status,     /* 16 BTA_DM_PM_BTM_STATUS_EVT */
            bta_dm_pm_timer,          /* 17 BTA_DM_PM_TIMER_EVT*/

            /* simple pairing events */
            bta_dm_confirm,           /* 18 BTA_DM_API_CONFIRM_EVT */

            bta_dm_set_encryption,    /* BTA_DM_API_SET_ENCRYPTION_EVT */

#if (BTM_LOCAL_IO_CAPS != BTM_IO_CAP_NONE)
            bta_dm_passkey_cancel,    /* 19 BTA_DM_API_PASKY_CANCEL_EVT */
#endif
#if (BTM_OOB_INCLUDED == TRUE)
            bta_dm_loc_oob,           /* 20 BTA_DM_API_LOC_OOB_EVT */
            bta_dm_ci_io_req_act,     /* 21 BTA_DM_CI_IO_REQ_EVT */
            bta_dm_ci_rmt_oob_act,    /* 22 BTA_DM_CI_RMT_OOB_EVT */
#endif /* BTM_OOB_INCLUDED */

            bta_dm_remove_device,      /*  BTA_DM_API_REMOVE_DEVICE_EVT */

#if BLE_INCLUDED == TRUE
            bta_dm_add_blekey,          /*  BTA_DM_API_ADD_BLEKEY_EVT           */
            bta_dm_add_ble_device,      /*  BTA_DM_API_ADD_BLEDEVICE_EVT        */
            bta_dm_ble_passkey_reply,   /*  BTA_DM_API_BLE_PASSKEY_REPLY_EVT    */
            bta_dm_security_grant,
            bta_dm_ble_set_bg_conn_type,
            bta_dm_ble_set_conn_params,      /* BTA_DM_API_BLE_CONN_PARAM_EVT */
            bta_dm_ble_set_scan_params,      /* BTA_DM_API_BLE_SCAN_PARAM_EVT */
            bta_dm_ble_observe,
            bta_dm_ble_update_conn_params,   /* BTA_DM_API_UPDATE_CONN_PARAM_EVT */
#if BLE_PRIVACY_SPT == TRUE
            bta_dm_ble_config_local_privacy,   /* BTA_DM_API_LOCAL_PRIVACY_EVT */
#endif
            bta_dm_ble_set_adv_params,     /* BTA_DM_API_BLE_SCAN_PARAM_EVT */
            bta_dm_ble_set_adv_config,     /* BTA_DM_API_BLE_SET_ADV_CONFIG_EVT */
            bta_dm_ble_set_scan_rsp,       /* BTA_DM_API_BLE_SET_SCAN_RSP_EVT */
            bta_dm_ble_broadcast,          /* BTA_DM_API_BLE_BROADCAST_EVT */
#if BLE_ANDROID_CONTROLLER_SCAN_FILTER == TRUE
            bta_dm_cfg_filter_cond,         /* BTA_DM_API_CFG_FILTER_COND_EVT */
            bta_dm_scan_filter_param_setup, /* BTA_DM_API_SCAN_FILTER_SETUP_EVT */
            bta_dm_enable_scan_filter,      /* BTA_DM_API_SCAN_FILTER_ENABLE_EVT */
#endif
            bta_dm_ble_multi_adv_enb,           /*  BTA_DM_API_BLE_MULTI_ADV_ENB_EVT*/
            bta_dm_ble_multi_adv_upd_param,     /*  BTA_DM_API_BLE_MULTI_ADV_PARAM_UPD_EVT */
            bta_dm_ble_multi_adv_data,          /*  BTA_DM_API_BLE_MULTI_ADV_DATA_EVT */
            btm_dm_ble_multi_adv_disable,       /*  BTA_DM_API_BLE_MULTI_ADV_DISABLE_EVT */
            bta_dm_ble_setup_storage,      /* BTA_DM_API_BLE_SETUP_STORAGE_EVT */
            bta_dm_ble_enable_batch_scan,  /* BTA_DM_API_BLE_ENABLE_BATCH_SCAN_EVT */
            bta_dm_ble_disable_batch_scan, /* BTA_DM_API_BLE_DISABLE_BATCH_SCAN_EVT */
            bta_dm_ble_read_scan_reports,  /* BTA_DM_API_BLE_READ_SCAN_REPORTS_EVT */
            bta_dm_ble_track_advertiser,   /* BTA_DM_API_BLE_TRACK_ADVERTISER_EVT */
            bta_dm_ble_get_energy_info,    /* BTA_DM_API_BLE_ENERGY_INFO_EVT */
#endif

#if ( BTM_EIR_SERVER_INCLUDED == TRUE )&&( BTA_EIR_CANNED_UUID_LIST != TRUE )&&(BTA_EIR_SERVER_NUM_CUSTOM_UUID > 0)
            bta_dm_update_eir_uuid,     /*  BTA_DM_API_UPDATE_EIR_UUID_EVT      */
#endif
#if (BTM_EIR_SERVER_INCLUDED == TRUE)
            bta_dm_set_eir_config,      /*  BTA_DM_API_SET_EIR_CONFIG_EVT       */
#endif

            bta_dm_enable_test_mode,    /*  BTA_DM_API_ENABLE_TEST_MODE_EVT     */
            bta_dm_disable_test_mode,   /*  BTA_DM_API_DISABLE_TEST_MODE_EVT    */
            bta_dm_execute_callback,     /*  BTA_DM_API_EXECUTE_CBACK_EVT        */
            bta_dm_set_afh_channel_assesment      /* BTA_DM_API_SET_AFH_CHANNEL_ASSESMENT_EVT */
        };
    }
--------------------------------------------------------------------------------------------------
Bta_dm_act.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\dm)
->  {
        /*******************************************************************************
         **
         ** Function         bta_dm_enable
         **
         ** Description      Initialises the BT device manager
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        void bta_dm_enable(tBTA_DM_MSG *p_data)
        {
            tBTA_SYS_HW_MSG *sys_enable_event;
            tBTA_DM_SEC sec_event;

            /* if already in use, return an error */
            if( bta_dm_cb.is_bta_dm_active == TRUE  )
            {
                APPL_TRACE_WARNING("bta_dm_enable - device already started by another application");
                memset(&sec_event.enable, 0, sizeof ( tBTA_DM_ENABLE ));
                sec_event.enable.status = BTA_FAILURE;
                if( p_data->enable.p_sec_cback != NULL  )
                    p_data->enable.p_sec_cback (BTA_DM_ENABLE_EVT, &sec_event);
                return;
            }

            /* first, register our callback to SYS HW manager */
            bta_sys_hw_register( BTA_SYS_HW_BLUETOOTH, bta_dm_sys_hw_cback );       // 注册BTA_SYS_HW_BLUETOOTH回调函数

            /* make sure security callback is saved - if no callback, do not erase the previous one,
               it could be an error recovery mechanism */
            if( p_data->enable.p_sec_cback != NULL  )
                bta_dm_cb.p_sec_cback = p_data->enable.p_sec_cback;
            /* notify BTA DM is now active */
            bta_dm_cb.is_bta_dm_active = TRUE;

            /* send a message to BTA SYS */
            if ((sys_enable_event = (tBTA_SYS_HW_MSG *) GKI_getbuf(sizeof(tBTA_SYS_HW_MSG))) != NULL)
            {
                sys_enable_event->hdr.event = BTA_SYS_API_ENABLE_EVT;
                sys_enable_event->hw_module = BTA_SYS_HW_BLUETOOTH;

                bta_sys_sendmsg(sys_enable_event);
            }
        }

        /*******************************************************************************
         **
         ** Function         bta_dm_sys_hw_cback
         **
         ** Description     callback register to SYS to get HW status updates
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        static void bta_dm_sys_hw_cback( tBTA_SYS_HW_EVT status )
        {
            DEV_CLASS   dev_class;
            tBTA_DM_SEC_CBACK           *temp_cback;
#if BLE_INCLUDED == TRUE
            UINT8                   key_mask = 0;
            BT_OCTET16              er;
            tBTA_BLE_LOCAL_ID_KEYS  id_key;
            tBT_UUID                app_uuid = {LEN_UUID_128,{0}};
#endif
            APPL_TRACE_DEBUG(" bta_dm_sys_hw_cback with event: %i" , status );

            /* On H/W error evt, report to the registered DM application callback */
            if (status == BTA_SYS_HW_ERROR_EVT) {
                if( bta_dm_cb.p_sec_cback != NULL )
                    bta_dm_cb.p_sec_cback(BTA_DM_HW_ERROR_EVT, NULL);
                return;
            }
            if( status == BTA_SYS_HW_OFF_EVT )
            {
                if( bta_dm_cb.p_sec_cback != NULL )
                    bta_dm_cb.p_sec_cback(BTA_DM_DISABLE_EVT, NULL);

                /* reinitialize the control block */
                memset(&bta_dm_cb, 0, sizeof(bta_dm_cb));

                /* unregister from SYS */
                bta_sys_hw_unregister( BTA_SYS_HW_BLUETOOTH );
                /* notify BTA DM is now unactive */
                bta_dm_cb.is_bta_dm_active = FALSE;
            }
            else
                if( status == BTA_SYS_HW_ON_EVT )
                {
                    /* FIXME: We should not unregister as the SYS shall invoke this callback on a H/W error.
                     * We need to revisit when this platform has more than one BLuetooth H/W chip */
                    //bta_sys_hw_unregister( BTA_SYS_HW_BLUETOOTH);

                    /* save security callback */
                    temp_cback = bta_dm_cb.p_sec_cback;
                    /* make sure the control block is properly initialized */
                    memset(&bta_dm_cb, 0, sizeof(bta_dm_cb));
                    /* and retrieve the callback */
                    bta_dm_cb.p_sec_cback=temp_cback;
                    bta_dm_cb.is_bta_dm_active = TRUE;

                    /* hw is ready, go on with BTA DM initialization */
                    memset(&bta_dm_search_cb, 0x00, sizeof(bta_dm_search_cb));
                    memset(&bta_dm_conn_srvcs, 0x00, sizeof(bta_dm_conn_srvcs));
                    memset(&bta_dm_di_cb, 0, sizeof(tBTA_DM_DI_CB));

                    memcpy(dev_class, bta_dm_cfg.dev_class, sizeof(dev_class));
                    BTM_SetDeviceClass (dev_class);

#if (defined BLE_INCLUDED && BLE_INCLUDED == TRUE)
                    /* load BLE local information: ID keys, ER if available */
                    bta_dm_co_ble_load_local_keys(&key_mask, er, &id_key);

                    if (key_mask & BTA_BLE_LOCAL_KEY_TYPE_ER)
                    {
                        BTM_BleLoadLocalKeys(BTA_BLE_LOCAL_KEY_TYPE_ER, (tBTM_BLE_LOCAL_KEYS *)&er);
                    }
                    if (key_mask & BTA_BLE_LOCAL_KEY_TYPE_ID)
                    {
                        BTM_BleLoadLocalKeys(BTA_BLE_LOCAL_KEY_TYPE_ID, (tBTM_BLE_LOCAL_KEYS *)&id_key);
                    }
#if ((defined BTA_GATT_INCLUDED) && (BTA_GATT_INCLUDED == TRUE))
                    bta_dm_search_cb.conn_id = BTA_GATT_INVALID_CONN_ID;
#endif
#endif

                    BTM_SecRegister((tBTM_APPL_INFO*)&bta_security);
                    BTM_SetDefaultLinkSuperTout(bta_dm_cfg.link_timeout);
                    BTM_WritePageTimeout(bta_dm_cfg.page_timeout);
                    bta_dm_cb.cur_policy = bta_dm_cfg.policy_settings;
                    BTM_SetDefaultLinkPolicy(bta_dm_cb.cur_policy);
#if (defined(BTM_BUSY_LEVEL_CHANGE_INCLUDED) && BTM_BUSY_LEVEL_CHANGE_INCLUDED == TRUE)
                    BTM_RegBusyLevelNotif (bta_dm_bl_change_cback, NULL, BTM_BL_UPDATE_MASK|BTM_BL_ROLE_CHG_MASK);
#else
                    BTM_AclRegisterForChanges(bta_dm_acl_change_cback);
#endif

#if BLE_VND_INCLUDED == TRUE
                    BTM_BleReadControllerFeatures (bta_dm_ctrl_features_rd_cmpl_cback);
#endif

                    /* Earlier, we used to invoke BTM_ReadLocalAddr which was just copying the bd_addr
                       from the control block and invoking the callback which was sending the DM_ENABLE_EVT.
                       But then we have a few HCI commands being invoked above which were still in progress
                       when the ENABLE_EVT was sent. So modified this to fetch the local name which forces
                       the DM_ENABLE_EVT to be sent only after all the init steps are complete */
                    BTM_ReadLocalDeviceNameFromController((tBTM_CMPL_CB *)bta_dm_local_name_cback);

                    bta_sys_rm_register((tBTA_SYS_CONN_CBACK*)bta_dm_rm_cback);

                    /* initialize bluetooth low power manager */
                    bta_dm_init_pm();

                    bta_sys_policy_register((tBTA_SYS_CONN_CBACK*)bta_dm_policy_cback);

#if (BLE_INCLUDED == TRUE && BTA_GATT_INCLUDED == TRUE)
                    memset (&app_uuid.uu.uuid128, 0x87, LEN_UUID_128);
                    bta_dm_gattc_register();
#endif

                }
                else
                    APPL_TRACE_DEBUG(" --- ignored event");

        }
    }
-------------------------------------------------------------------------------------------------
Bta_sys_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        void bta_sys_hw_register( tBTA_SYS_HW_MODULE module, tBTA_SYS_HW_CBACK *cback)
        {
            bta_sys_cb.sys_hw_cback[module]=cback;
        }

        /*******************************************************************************
         **
         ** Function         bta_sys_sendmsg
         **
         ** Description      Send a GKI message to BTA.  This function is designed to
         **                  optimize sending of messages to BTA.  It is called by BTA
         **                  API functions and call-in functions.
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        void bta_sys_sendmsg(void *p_msg)
        {
            GKI_send_msg(bta_sys_cb.task_id, p_bta_sys_cfg->mbox, p_msg);
        }
    }
-------------------------------------------------------------------------------------------------
Bta_sys.h (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /* events sent to SYS HW manager - must be kept synchronized with tables in bta_sys_main.c */
        enum
        {
            /* device manager local device API events */
            BTA_SYS_API_ENABLE_EVT = BTA_SYS_EVT_START(BTA_ID_SYS),             // BTA_SYS_API_ENABLE_EVT其实是BTA_ID_SYS左移8位得到的值
            BTA_SYS_EVT_ENABLED_EVT,
            BTA_SYS_EVT_STACK_ENABLED_EVT,
            BTA_SYS_API_DISABLE_EVT,
            BTA_SYS_EVT_DISABLED_EVT,
            BTA_SYS_ERROR_EVT,

            BTA_SYS_MAX_EVT
        };
    }
------------------------------------------------------------------------------------------------
所以BTA_ID_SYS的处理函数就是由bta_sys_hw_reg的bta_sys_sm_execute处理：

Bta_sys_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\bta\sys)
->  {
        /* action function list */
        const tBTA_SYS_ACTION bta_sys_action[] =
        {
            /* device manager local device API events - cf bta_sys.h for events */
            bta_sys_hw_api_enable,             /* 0  BTA_SYS_HW_API_ENABLE_EVT    */
            bta_sys_hw_evt_enabled,           /* 1  BTA_SYS_HW_EVT_ENABLED_EVT */
            bta_sys_hw_evt_stack_enabled,       /* 2  BTA_SYS_HW_EVT_STACK_ENABLED_EVT */
            bta_sys_hw_api_disable,             /* 3  BTA_SYS_HW_API_DISABLE_EVT     */
            bta_sys_hw_evt_disabled,           /* 4  BTA_SYS_HW_EVT_DISABLED_EVT  */
            bta_sys_hw_error                        /* 5   BTA_SYS_HW_ERROR_EVT  */
        };
    
        /*******************************************************************************
         **
         ** Function         bta_dm_sm_execute
         **
         ** Description      State machine event handling function for DM
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BOOLEAN bta_sys_sm_execute(BT_HDR *p_msg)
        {
            BOOLEAN freebuf = TRUE;
            tBTA_SYS_ST_TBL      state_table;
            UINT8               action;
            int                 i;

            APPL_TRACE_EVENT("bta_sys_sm_execute state:%d, event:0x%x",  bta_sys_cb.state, p_msg->event);

            /* look up the state table for the current state */
            state_table = bta_sys_st_tbl[bta_sys_cb.state];
            /* update state */
            bta_sys_cb.state = state_table[p_msg->event & 0x00ff][BTA_SYS_NEXT_STATE];

            /* execute action functions */
            for (i = 0; i < BTA_SYS_ACTIONS; i++)
            {
                if ((action = state_table[p_msg->event & 0x00ff][i]) != BTA_SYS_IGNORE)
                {
                    (*bta_sys_action[action])( (tBTA_SYS_HW_MSG*) p_msg);
                }
                else
                {
                    break;
                }
            }
            return freebuf;
        }

        /*******************************************************************************
         **
         ** Function         bta_sys_hw_enable
         **
         ** Description     this function is called after API enable and HW has been turned on
         **
         **
         ** Returns          success or failure
         **
         *******************************************************************************/

        void bta_sys_hw_api_enable( tBTA_SYS_HW_MSG *p_sys_hw_msg )
        {
            if ((!bta_sys_cb.sys_hw_module_active) && (bta_sys_cb.state != BTA_SYS_HW_ON))
            {
                /* register which HW module was turned on */
                bta_sys_cb.sys_hw_module_active |=  ((UINT32)1 << p_sys_hw_msg->hw_module );

                /* use call-out to power-up HW */
                bta_sys_hw_co_enable(p_sys_hw_msg->hw_module);
            }
            else
            {
                /* register which HW module was turned on */
                bta_sys_cb.sys_hw_module_active |=  ((UINT32)1 << p_sys_hw_msg->hw_module );

                /* HW already in use, so directly notify the caller */
                if (bta_sys_cb.sys_hw_cback[p_sys_hw_msg->hw_module ]!= NULL )
                    bta_sys_cb.sys_hw_cback[p_sys_hw_msg->hw_module ](  BTA_SYS_HW_ON_EVT   );  // 调用bta_dm_sys_hw_cback，传参BTA_SYS_HW_ON_EVT
            }

            APPL_TRACE_EVENT ("bta_sys_hw_api_enable for %d, active modules 0x%04X",
                    p_sys_hw_msg->hw_module, bta_sys_cb.sys_hw_module_active);

        }
    }
-------------------------------------------------------------------------------------------------
Bluetooth.h (z:\home\ballack\prj\rk3288\hardware\libhardware\include\hardware)
->  {
        typedef struct {
            /** set to sizeof(bt_callbacks_t) */
            size_t size;
            adapter_state_changed_callback adapter_state_changed_cb;
            adapter_properties_callback adapter_properties_cb;
            remote_device_properties_callback remote_device_properties_cb;
            device_found_callback device_found_cb;
            discovery_state_changed_callback discovery_state_changed_cb;
            pin_request_callback pin_request_cb;
            ssp_request_callback ssp_request_cb;
            bond_state_changed_callback bond_state_changed_cb;
            acl_state_changed_callback acl_state_changed_cb;
            callback_thread_event thread_evt_cb;
            dut_mode_recv_callback dut_mode_recv_cb;
            le_test_mode_callback le_test_mode_cb;
            energy_info_callback energy_info_cb;
        } bt_callbacks_t;
    }
-------------------------------------------------------------------------------------------------------------------->
Btif_core.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        void btif_enable_bluetooth_evt(tBTA_STATUS status, BD_ADDR local_bd)
        {
            HAL_CBACK(bt_hal_cbacks, adapter_state_changed_cb, BT_STATE_ON);    // 即调用adapter_state_change_callback
        }
    }
-------------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static void classInitNative(JNIEnv* env, jclass clazz) {
            jclass jniCallbackClass =
                env->FindClass("com/android/bluetooth/btservice/JniCallbacks");
            sJniCallbacksField = env->GetFieldID(clazz, "mJniCallbacks",
                    "Lcom/android/bluetooth/btservice/JniCallbacks;");

            method_stateChangeCallback = env->GetMethodID(jniCallbackClass, "stateChangeCallback", "(I)V");
        }

        static void adapter_state_change_callback(bt_state_t status) {
            if (!checkCallbackThread()) {
                ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
                return;
            }
            ALOGV("%s: Status is: %d", __FUNCTION__, status);

            callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);

            checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
JniCallbacks.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void stateChangeCallback(int status) {
            mAdapterStateMachine.stateChangeCallback(status);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void stateChangeCallback(int status) {
            if (status == AbstractionLayer.BT_STATE_OFF) {
                sendMessage(DISABLED);
            } else if (status == AbstractionLayer.BT_STATE_ON) {
                // We should have got the property change for adapter and remote devices.
                sendMessage(ENABLED_READY);
            } else {
                errorLog("Incorrect status in stateChangeCallback");
            }
        }
    }

private class PendingCommandState extends State {
    public boolean processMessage(Message msg) {
        switch (msg.what) {
            case ENABLED_READY:
                removeMessages(ENABLE_TIMEOUT);
                adapterProperties.onBluetoothReady();
                mPendingCommandState.setTurningOn(false);
                transitionTo(mOnState);
                notifyAdapterStateChange(BluetoothAdapter.STATE_ON);
                break;
            }
        }
    }
}
->  {
        private class OnState extends State {
            @Override
                public void enter() {
                    infoLog("Entering On State");
                    AdapterService adapterService = mAdapterService;
                    adapterService.autoConnect();
                }

            @Override
                public boolean processMessage(Message msg) {
                    AdapterProperties adapterProperties = mAdapterProperties;
                    switch(msg.what) {
                    
                    }
                }
            }
    }
-------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        // 打开蓝牙，如果之前有连接过蓝牙设备，则自动连接！
        public void autoConnect(){
            if (getState() != BluetoothAdapter.STATE_ON){
                errorLog("BT is not ON. Exiting autoConnect");
                return;
            }
            if (isQuietModeEnabled() == false) {
                if (DBG) debugLog( "Initiate auto connection on BT on...");
                autoConnectHeadset();
                autoConnectA2dp();
            }
            else {
                if (DBG) debugLog( "BT is in Quiet mode. Not initiating  auto connections");
            }
        }
    }
-------------------------------------------------------------------------------------------------------------------->
BluetoothSettings.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void onBluetoothStateChanged(int bluetoothState) {
            super.onBluetoothStateChanged(bluetoothState);
            updateContent(bluetoothState);
        }

        private void updateContent(int bluetoothState) {
            final PreferenceScreen preferenceScreen = getPreferenceScreen();
            int messageId = 0;

            switch (bluetoothState) {
                case BluetoothAdapter.STATE_ON:
                    if (!mInitialScanStarted) {
                        startScanning();
                    }
            }
        }

        private void startScanning() {
            mLocalAdapter.startScanning(true);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        void startScanning(boolean force) {
            // Only start if we're not already scanning
            if (!mAdapter.isDiscovering()) {
                if (!force) {
                    // Don't scan more than frequently than SCAN_EXPIRATION_MS,
                    // unless forced
                    if (mLastScan + SCAN_EXPIRATION_MS > System.currentTimeMillis()) {
                        return;
                    }

                    // If we are playing music, don't scan unless forced.
                    A2dpProfile a2dp = mProfileManager.getA2dpProfile();
                    if (a2dp != null && a2dp.isA2dpPlaying()) {
                        return;
                    }
                }

                if (mAdapter.startDiscovery()) {
                    mLastScan = System.currentTimeMillis();
                }
            }
        }
    }
--------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public boolean startDiscovery() {
            return mService.startDiscovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        public boolean startDiscovery() {
            AdapterService service = getService();
            return service.startDiscovery();
        }
        ->  {
                boolean startDiscovery() {
                    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                            "Need BLUETOOTH ADMIN permission");

                    return startDiscoveryNative();
                }
            }
    }
--------------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static JNINativeMethod sMethods[] = {
            {"startDiscoveryNative", "()Z", (void*) startDiscoveryNative},
        }

        static jboolean startDiscoveryNative(JNIEnv* env, jobject obj) {
            int ret = sBluetoothInterface->start_discovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Bluetooth.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        static int start_discovery(void)
        {
            /* sanity check */
            if (interface_ready() == FALSE)
                return BT_STATUS_NOT_READY;

            return btif_dm_start_discovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Btif_dm.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        bt_status_t btif_dm_start_discovery(void)
        {
            /* find nearby devices */
            BTA_DmSearch(&inq_params, services, bte_search_devices_evt);
        }
    }
--------------------------------------------------------------------------------------------------------------------->


