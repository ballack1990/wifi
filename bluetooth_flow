BluetoothSettings.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void onActivityCreated(Bundle savedInstanceState) {
            final SettingsActivity activity = (SettingsActivity) getActivity();
            mSwitchBar = activity.getSwitchBar();

            mBluetoothEnabler = new BluetoothEnabler(activity, mSwitchBar);             // 创建BluetoothEnabler对象
            mBluetoothEnabler.setupSwitchBar();
        }
    }
---------------------------------------------------------------------------------------------------------------->
BluetoothEnabler.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public BluetoothEnabler(Context context, SwitchBar switchBar) {
            mContext = context;
            mSwitchBar = switchBar;
            mSwitch = switchBar.getSwitch();
            mValidListener = false;

            LocalBluetoothManager manager = LocalBluetoothManager.getInstance(context);     // 获取LocalBluetoothManager对象
            if (manager == null) {
                // Bluetooth is not supported
                mLocalAdapter = null;
                mSwitch.setEnabled(false);
            } else {
                mLocalAdapter = manager.getBluetoothAdapter();                              // 获取LocalBluetoothAdapter对象
            }
            mIntentFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
        }

        public void onSwitchChanged(Switch switchView, boolean isChecked) {
            if (mLocalAdapter != null) {
                mLocalAdapter.setBluetoothEnabled(isChecked);                               // 打开/关闭 蓝牙
            }
        }
    }
------------------------------------------------------------------------------------------------------------------>
LocalBluetoothManager.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public static synchronized LocalBluetoothManager getInstance(Context context) {
            if (sInstance == null) {
                LocalBluetoothAdapter adapter = LocalBluetoothAdapter.getInstance();        // 获取LocalBluetoothAdapter对象
                if (adapter == null) {
                    return null;
                }
                // This will be around as long as this process is
                Context appContext = context.getApplicationContext();
                sInstance = new LocalBluetoothManager(adapter, appContext);                 // 第一次调用，创建LocalBluetoothManager对象
            }

            return sInstance;
        }

        private LocalBluetoothManager(LocalBluetoothAdapter adapter, Context context) {
            mContext = context;
            mLocalAdapter = adapter;                                                        // 构造的时候传入Adapter

            mCachedDeviceManager = new CachedBluetoothDeviceManager(context);
            mEventManager = new BluetoothEventManager(mLocalAdapter,
                    mCachedDeviceManager, context);
            mProfileManager = new LocalBluetoothProfileManager(context,
                    mLocalAdapter, mCachedDeviceManager, mEventManager);
        }

        public LocalBluetoothAdapter getBluetoothAdapter() {                                // 返回LocalBluetoothManager getInstance创建的Adapter
            return mLocalAdapter;
        }
    }
------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        static synchronized LocalBluetoothAdapter getInstance() {
            if (sInstance == null) {
                BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();        // 第一次调用，创建BluetoothAdapter对象
                if (adapter != null) {
                    sInstance = new LocalBluetoothAdapter(adapter);
                }
            }

            return sInstance;
        }

        private LocalBluetoothAdapter(BluetoothAdapter adapter) {
            mAdapter = adapter;                                                         // 保存BluetoothAdapter对象
        }
    }
---------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public static synchronized BluetoothAdapter getDefaultAdapter() {
            if (sAdapter == null) {
                IBinder b = ServiceManager.getService(BLUETOOTH_MANAGER_SERVICE);       // 获取bluetooth_manager服务
                if (b != null) {
                    IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);   // 获取BluetoothManager对象
                    sAdapter = new BluetoothAdapter(managerService);                    // 第一次调用，创建BluetoothAdapter对象
                } else {
                    Log.e(TAG, "Bluetooth binder is null");
                }
            }
            return sAdapter;
        }

        BluetoothAdapter(IBluetoothManager managerService) {
            if (managerService == null) {
                throw new IllegalArgumentException("bluetooth manager service is null");
            }
            try {
                mService = managerService.registerAdapter(mManagerCallback);            // 向服务注册Adapter
            } catch (RemoteException e) {Log.e(TAG, "", e);}
            mManagerService = managerService;
            mLeScanClients = new HashMap<LeScanCallback, ScanCallback>();
        }
    }
------------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void setBluetoothEnabled(boolean enabled) {
            boolean success = enabled
                ? mAdapter.enable()
                : mAdapter.disable();

            if (success) {
                setBluetoothStateInt(enabled
                        ? BluetoothAdapter.STATE_TURNING_ON
                        : BluetoothAdapter.STATE_TURNING_OFF);
            } else {
                if (Utils.V) {
                    Log.v(TAG, "setBluetoothEnabled call, manager didn't return " +
                            "success for enabled: " + enabled);
                }

                syncBluetoothState();
            }
        }
    }
------------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public boolean enable() {
            if (isEnabled() == true){
                if (DBG) Log.d(TAG, "enable(): BT is already enabled..!");
                return true;
            }
            try {
                return mManagerService.enable();                                // 调用底层服务打开蓝牙
            } catch (RemoteException e) {Log.e(TAG, "", e);}
            return false;
        }
    }
------------------------------------------------------------------------------------------------------------------------>
现在来展开一下mManagerService,可以看到上面的定义是:
IBluetoothManager managerService = IBluetoothManager.Stub.asInterface(b);

private final IBluetoothManager mManagerService;
mManagerService = managerService;

------------------------------------------------------------------------------------------------------------------------>
IBluetoothManager.aidl(z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        interface IBluetoothManager
        {
            IBluetooth registerAdapter(in IBluetoothManagerCallback callback);
            void unregisterAdapter(in IBluetoothManagerCallback callback);
            void registerStateChangeCallback(in IBluetoothStateChangeCallback callback);
            void unregisterStateChangeCallback(in IBluetoothStateChangeCallback callback);
            boolean isEnabled();
            boolean enable();
            boolean enableNoAutoConnect();
            boolean disable(boolean persist);
            IBluetoothGatt getBluetoothGatt();

            boolean bindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);
            void unbindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);

            String getAddress();
            String getName();
        }
    }
------------------------------------------------------------------------------------------------------------------------>
BluetoothManagerService服务是哪里启动的：
SystemServer.java (z:\home\ballack\prj\rk3288\frameworks\base\services\java\com\android\server)
->  {
        private void run() {
            startOtherServices();
        }
    
        private void startOtherServices() {
            Slog.i(TAG, "Bluetooth Manager Service");
            bluetooth = new BluetoothManagerService(context);
            ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth);
        }
    }
------------------------------------------------------------------------------------------------------------------------>
回到上面提到的：  
mManagerService.enable(); 

BluetoothManagerService.java (z:\home\ballack\prj\rk3288\frameworks\base\services\core\java\com\android\server)
->  {
        class BluetoothManagerService extends IBluetoothManager.Stub {
            BluetoothManagerService(Context context) {
                mHandler = new BluetoothHandler(IoThread.get().getLooper());
            }
        }

        public boolean enable() {
            persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
            sendEnableMsg(false);
        }

        private void sendEnableMsg(boolean quietMode) {
            mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_ENABLE,
                        quietMode ? 1 : 0, 0));
        }

        private class BluetoothHandler extends Handler {
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case MESSAGE_ENABLE:
                        if (DBG) {
                            Log.d(TAG, "MESSAGE_ENABLE: mBluetooth = " + mBluetooth);
                        }
                        mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mEnable = true;
                        handleEnable(msg.arg1 == 1);
                        break;

                    case MESSAGE_REGISTER_ADAPTER:
                        {
                            IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                            boolean added = mCallbacks.register(callback);
                            Log.d(TAG,"Added callback: " +  (callback == null? "null": callback)  +":" +added );
                        }
                        break;
                }
            }
        }

        private IBluetooth mBluetooth;

        private void handleEnable(boolean quietMode) {
            if (!mQuietEnable) {
                if(!mBluetooth.enable()) {
                    Log.e(TAG,"IBluetooth.enable() returned false");
                }
            }
            else {
                if(!mBluetooth.enableNoAutoConnect()) {
                    Log.e(TAG,"IBluetooth.enableNoAutoConnect() returned false");
                }
            }
        }
    }
----------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        public class AdapterService extends Service {
            public void onCreate() {
                mBinder = new AdapterServiceBinder(this);
                mAdapterProperties = new AdapterProperties(this);
                mAdapterStateMachine =  AdapterState.make(this, mAdapterProperties);
                mJniCallbacks =  new JniCallbacks(mAdapterStateMachine, mAdapterProperties);
                initNative();
                mNativeAvailable=true;
                mCallbacks = new RemoteCallbackList<IBluetoothCallback>();
                //Load the name and address
                getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDADDR);
                getAdapterPropertyNative(AbstractionLayer.BT_PROPERTY_BDNAME);
                mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
                mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);

                registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));
            }
        }

        private static class AdapterServiceBinder extends IBluetooth.Stub {                         // AdapterServiceBinder实现了IBluetooth接口
            public boolean enable() {
                if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
                        (!Utils.checkCaller())) {
                    Log.w(TAG, "enable() - Not allowed for non-active user and non system user");
                    return false;
                }

                AdapterService service = getService();
                if (service == null) return false;
                return service.enable();
            }
        }
    }
    ->  {
             public synchronized boolean enable(boolean quietMode) {
                 enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                         "Need BLUETOOTH ADMIN permission");
                 debugLog("enable() - Enable called with quiet mode status =  " + mQuietmode);
                 mQuietmode  = quietMode;
                 Message m = mAdapterStateMachine.obtainMessage(AdapterState.USER_TURN_ON);
                 mAdapterStateMachine.sendMessage(m);
                 return true;
             }
        }
----------------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        final class AdapterState extends StateMachine {
            public static AdapterState make(AdapterService service, AdapterProperties adapterProperties) {
                AdapterState as = new AdapterState(service, adapterProperties);
                as.start();
                return as;
            }

            private AdapterState(AdapterService service, AdapterProperties adapterProperties) {
                addState(mOnState);
                addState(mOffState);
                addState(mPendingCommandState);
                mAdapterService = service;
                mAdapterProperties = adapterProperties;
                setInitialState(mOffState);
            }
        }
    }
    ->  {
            private class OffState extends State {
                public boolean processMessage(Message msg) {
                    AdapterService adapterService = mAdapterService;

                    switch(msg.what) {
                        case USER_TURN_ON:
                            notifyAdapterStateChange(BluetoothAdapter.STATE_TURNING_ON);    // 更新property状态，调用onBluetoothStateChange
                            mPendingCommandState.setTurningOn(true);
                            transitionTo(mPendingCommandState);                             // 切换到PendingCommandState模式
                            sendMessageDelayed(START_TIMEOUT, START_TIMEOUT_DELAY);
                            adapterService.processStart();
                            break;
                    }
                }
            }
        }
----------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void processStart() {
            debugLog("processStart()");
            Class[] supportedProfileServices = Config.getSupportedProfiles();
            //Initialize data objects
            for (int i=0; i < supportedProfileServices.length;i++) {
                mProfileServicesState.put(supportedProfileServices[i].getName(),BluetoothAdapter.STATE_OFF);
            }
            mRemoteDevices = new RemoteDevices(this);
            mAdapterProperties.init(mRemoteDevices);

            if (DBG) {debugLog("processStart(): Make Bond State Machine");}
            mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);

            mJniCallbacks.init(mBondStateMachine,mRemoteDevices);

            //FIXME: Set static instance here???
            setAdapterService(this);

            //Start profile services
            if (!mProfilesStarted && supportedProfileServices.length >0) {
                //Startup all profile services
                setProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_ON);
            }else {
                if (DBG) {debugLog("processStart(): Profile Services alreay started");}
                mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.STARTED));
            }
        }
    }
    ->  {
        ---------------------------------------------------------------------------------------------------------
            Config.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
            ->  {
                    private static final int[]  PROFILE_SERVICES_FLAG = {
                        R.bool.profile_supported_hs_hfp,
                        R.bool.profile_supported_a2dp,
                        R.bool.profile_supported_a2dp_sink,
                        R.bool.profile_supported_hid,
                        R.bool.profile_supported_hdp,
                        R.bool.profile_supported_pan,
                        R.bool.profile_supported_gatt,
                        R.bool.profile_supported_map,
                        R.bool.profile_supported_hfpclient,
                        R.bool.profile_supported_avrcp_controller,
                    };

                    private static Class[] SUPPORTED_PROFILES = new Class[0];

                    static void init(Context ctx) {
                        if (ctx == null) {
                            return;
                        }
                        Resources resources = ctx.getResources();
                        if (resources == null) {
                            return;
                        }
                        ArrayList<Class> profiles = new ArrayList<Class>(PROFILE_SERVICES.length);
                        for (int i=0; i < PROFILE_SERVICES_FLAG.length; i++) {
                            boolean supported = resources.getBoolean(PROFILE_SERVICES_FLAG[i]);
                            if (supported) {
                                Log.d(TAG, "Adding " + PROFILE_SERVICES[i].getSimpleName());
                                profiles.add(PROFILE_SERVICES[i]);
                            }
                        }
                        int totalProfiles = profiles.size();
                        SUPPORTED_PROFILES = new Class[totalProfiles];
                        profiles.toArray(SUPPORTED_PROFILES);
                    }

                    static Class[]  getSupportedProfiles() {
                        return SUPPORTED_PROFILES;
                    }
                }
                ->  {
                    ----------------------------------------------------------------------------------------------
                         config.xml (prj/rk3288/packages/apps/Bluetooth/res/values)
                         -> {
                                <resources>
                                     <bool name="profile_supported_a2dp">true</bool>
                                     <bool name="profile_supported_a2dp_sink">false</bool>
                                     <bool name="profile_supported_hdp">true</bool>
                                     <bool name="profile_supported_hs_hfp">true</bool>
                                     <bool name="profile_supported_hfpclient">false</bool>
                                     <bool name="profile_supported_hid">true</bool>
                                     <bool name="profile_supported_opp">true</bool>
                                     <bool name="profile_supported_pan">true</bool>
                                     <bool name="profile_supported_pbap">true</bool>
                                     <bool name="profile_supported_gatt">true</bool>
                                     <bool name="pbap_include_photos_in_vcard">false</bool>
                                     <bool name="pbap_use_profile_for_owner_vcard">true</bool>
                                     <bool name="profile_supported_map">true</bool>
                                     <bool name="profile_supported_avrcp_controller">false</bool>
                                </resources>
                            }
                    }
        }
---------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        private class PendingCommandState extends State {
            switch (msg.what) {
                case STARTED:   
                    //Enable
                    boolean ret = adapterService.enableNative();
                    if (!ret) {
                        Log.e(TAG, "Error while turning Bluetooth On");
                        notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                        transitionTo(mOffState);
                    } else {
                        sendMessageDelayed(ENABLE_TIMEOUT, ENABLE_TIMEOUT_DELAY);
                    }
                    break;
            }
        }
    }
---------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static JNINativeMethod sMethods[] = {
            {"classInitNative", "()V", (void *) classInitNative},
            {"initNative", "()Z", (void *) initNative},
            {"enableNative", "()Z",  (void*) enableNative},
        };
    }
---------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static void classInitNative(JNIEnv* env, jclass clazz) {
            char value[PROPERTY_VALUE_MAX];
            property_get("bluetooth.mock_stack", value, "");

            const char *id = (strcmp(value, "1")? BT_STACK_MODULE_ID : BT_STACK_TEST_MODULE_ID);

            char type[64];
            check_wifi_chip_type_string(type);
            if (!strncmp(type, "RTL", 3)) {
                ALOGD("%s, load %s.default.so", __func__, BT_STACK_RTK_MODULE_ID);
                err = hw_get_module(BT_STACK_RTK_MODULE_ID, (hw_module_t const**)&module);
            } else {
                ALOGD("%s, load %s.default.so", __func__, id);                              // bluetooth.default.so
                err = hw_get_module(id, (hw_module_t const**)&module);
            }

            if (err == 0) {
                hw_device_t* abstraction;
                err = module->methods->open(module, id, &abstraction);
                if (err == 0) {
                    bluetooth_module_t* btStack = (bluetooth_module_t *)abstraction;
                    sBluetoothInterface = btStack->get_bluetooth_interface();               // 获取蓝牙HAL控制接口
                } else {
                    ALOGE("Error while opening Bluetooth library");
                }
            } else {
                ALOGE("No Bluetooth Library found");
            }
        }

        static bt_callbacks_t sBluetoothCallbacks = {
            sizeof(sBluetoothCallbacks),
            adapter_state_change_callback,
            adapter_properties_callback,
            remote_device_properties_callback,
            device_found_callback,
            discovery_state_changed_callback,
            pin_request_callback,
            ssp_request_callback,
            bond_state_changed_callback,
            acl_state_changed_callback,
            callback_thread_event,
            dut_mode_recv_callback,

            le_test_mode_recv_callback,
            energy_info_recv_callback
        };

        static bool initNative(JNIEnv* env, jobject obj) {
            ALOGV("%s:",__FUNCTION__);

            sJniAdapterServiceObj = env->NewGlobalRef(obj);
            sJniCallbacksObj = env->NewGlobalRef(env->GetObjectField(obj, sJniCallbacksField));

            if (sBluetoothInterface) {
                int ret = sBluetoothInterface->init(&sBluetoothCallbacks);                  // 初始化蓝牙HAL控制接口, 调用init接口
                if (ret != BT_STATUS_SUCCESS) {
                    ALOGE("Error while setting the callbacks: %d\n", ret);
                    sBluetoothInterface = NULL;
                    return JNI_FALSE;
                }
                ret = sBluetoothInterface->set_os_callouts(&sBluetoothOsCallouts);
                if (ret != BT_STATUS_SUCCESS) {
                    ALOGE("Error while setting Bluetooth callouts: %d\n", ret);
                    sBluetoothInterface->cleanup();
                    sBluetoothInterface = NULL;
                    return JNI_FALSE;
                }

                if ( (sBluetoothSocketInterface = (btsock_interface_t *)
                            sBluetoothInterface->get_profile_interface(BT_PROFILE_SOCKETS_ID)) == NULL) {
                    ALOGE("Error getting socket interface");
                }

                if ( (sBluetoothMceInterface = (btmce_interface_t *)
                            sBluetoothInterface->get_profile_interface(BT_PROFILE_MAP_CLIENT_ID)) == NULL) {
                    ALOGE("Error getting mapclient interface");
                } else {
                    if ( (sBluetoothMceInterface->init(&sBluetoothMceCallbacks)) != BT_STATUS_SUCCESS) {
                        ALOGE("Failed to initialize Bluetooth MCE");
                        sBluetoothMceInterface = NULL;
                    }
                }

                return JNI_TRUE;
            }
            return JNI_FALSE;
        }

        static jboolean enableNative(JNIEnv* env, jobject obj) {
            int ret = sBluetoothInterface->enable();
            result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;                 // 使能蓝牙HAL控制接口，调用enable函数
            return result;
        }   
    }
---------------------------------------------------------------------------------------------------->
Bluetooth.h (z:\home\ballack\prj\rk3288\hardware\libhardware\include\hardware)
->  {
        /**
         * The Bluetooth Hardware Module ID
         */

        #define BT_HARDWARE_MODULE_ID "bluetooth"
        #define BT_STACK_MODULE_ID "bluetooth"
        #define BT_STACK_TEST_MODULE_ID "bluetooth_test"
        #define BT_STACK_RTK_MODULE_ID "bluetooth_rtk"

        /* Bluetooth profile interface IDs */

        #define BT_PROFILE_HANDSFREE_ID "handsfree"
        #define BT_PROFILE_HANDSFREE_CLIENT_ID "handsfree_client"
        #define BT_PROFILE_ADVANCED_AUDIO_ID "a2dp"
        #define BT_PROFILE_ADVANCED_AUDIO_SINK_ID "a2dp_sink"
        #define BT_PROFILE_HEALTH_ID "health"
        #define BT_PROFILE_SOCKETS_ID "socket"
        #define BT_PROFILE_HIDHOST_ID "hidhost"
        #define BT_PROFILE_PAN_ID "pan"
        #define BT_PROFILE_MAP_CLIENT_ID "map_client"

        #define BT_PROFILE_GATT_ID "gatt"
        #define BT_PROFILE_AV_RC_ID "avrcp"
        #define BT_PROFILE_AV_RC_CTRL_ID "avrcp_ctrl"
    }
---------------------------------------------------------------------------------------------------->
Bluetooth.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        static const bt_interface_t bluetoothInterface = {
            sizeof(bluetoothInterface),
            init,
            enable,
            disable,
            enable_radio,
            disable_radio,
            cleanup,
            get_adapter_properties,
            get_adapter_property,
            set_adapter_property,
            get_remote_device_properties,
            get_remote_device_property,
            set_remote_device_property,
            get_remote_service_record,
            get_remote_services,
            start_discovery,
            cancel_discovery,
            create_bond,
            remove_bond,
            cancel_bond,
            get_connection_state,
            pin_reply,
            ssp_reply,
            get_profile_interface,
            dut_mode_configure,
            dut_mode_send,
        #if BLE_INCLUDED == TRUE
            le_test_mode,
        #else
            NULL,
        #endif
            config_hci_snoop_log,
            set_os_callouts,
            read_energy_info,
            get_fm_interface
        };

        static int init(bt_callbacks_t* callbacks )
        {
            ALOGI("init");

            /* sanity check */
            if (interface_ready() == TRUE)
                return BT_STATUS_DONE;

            /* store reference to user callbacks */
            bt_hal_cbacks = callbacks;                      // bt_hal_cbacks即为sBluetoothCallbacks

            /* add checks for individual callbacks ? */

            bt_utils_init();

            /* init btif */
            btif_init_bluetooth();                          // 初始化btif

            return BT_STATUS_SUCCESS;
        }

        static int enable( void )
        {
            ALOGI("enable");

            /* sanity check */
            if (interface_ready() == FALSE)
                return BT_STATUS_NOT_READY;

            return btif_enable_bluetooth();
        }

        const bt_interface_t* bluetooth__get_bluetooth_interface ()
        {
            /* fixme -- add property to disable bt interface ? */

            return &bluetoothInterface;
        }

        static int open_bluetooth_stack (const struct hw_module_t* module, char const* name,
                struct hw_device_t** abstraction)
        {
            UNUSED(name);

            bluetooth_device_t *stack = malloc(sizeof(bluetooth_device_t) );
            memset(stack, 0, sizeof(bluetooth_device_t) );
            stack->common.tag = HARDWARE_DEVICE_TAG;
            stack->common.version = 0;
            stack->common.module = (struct hw_module_t*)module;
            stack->common.close = close_bluetooth_stack;
            stack->get_bluetooth_interface = bluetooth__get_bluetooth_interface;
            *abstraction = (struct hw_device_t*)stack;
            return 0;
        }


        static struct hw_module_methods_t bt_stack_module_methods = {
            .open = open_bluetooth_stack,
        };

        struct hw_module_t HAL_MODULE_INFO_SYM = {
            .tag = HARDWARE_MODULE_TAG,
            .version_major = 1,
            .version_minor = 0,
            .id = BT_HARDWARE_MODULE_ID,
            .name = "Bluetooth Stack",
            .author = "The Android Open Source Project",
            .methods = &bt_stack_module_methods
        };
    }
------------------------------------------------------------------------------------------------------->
Btif_common.h (external\bluetooth\bluedroid\btif\include)
->  {
        /**
         * PROPERTY_BT_BDADDR_PATH
         * The property key stores the storage location of Bluetooth Device Address
         */
        #ifndef PROPERTY_BT_BDADDR_PATH
        #define PROPERTY_BT_BDADDR_PATH         "ro.bt.bdaddr_path"
        #endif

        /**
         * PERSIST_BDADDR_PROPERTY
         * If there is no valid bdaddr available from PROPERTY_BT_BDADDR_PATH,
         * generating a random BDADDR and keeping it in the PERSIST_BDADDR_DROP.
         */
        #ifndef PERSIST_BDADDR_PROPERTY
        #define PERSIST_BDADDR_PROPERTY         "persist.service.bdroid.bdaddr"
        #endif
    }
------------------------------------------------------------------------------------------------------->
Btif_core.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        static void btif_fetch_local_bdaddr(bt_bdaddr_t *local_addr)
        {
            char val[256];
            uint8_t valid_bda = FALSE;
            int val_size = 0;
            const uint8_t null_bdaddr[BD_ADDR_LEN] = {0,0,0,0,0,0};

            {// cmy@2012-11-28: Get local bdaddr from vflash
                int vflash_fd = open("/dev/vflash", O_RDONLY);                                  // 可以看到先从/dev/vflash读取蓝牙地址
                if (vflash_fd > 0)
                {
                    char bd_addr[6] = {0};
                    BTIF_TRACE_DEBUG("Get local bdaddr from vflash");
                    #define VFLASH_READ_BDA  0x01
                    if(ioctl(vflash_fd, VFLASH_READ_BDA, (unsigned long)bd_addr) >= 0
                            && memcmp(bd_addr, null_bdaddr, BD_ADDR_LEN) != 0)
                    {
                        local_addr->address[0] = bd_addr[5];
                        local_addr->address[1] = bd_addr[4];
                        local_addr->address[2] = bd_addr[3];
                        local_addr->address[3] = bd_addr[2];
                        local_addr->address[4] = bd_addr[1];
                        local_addr->address[5] = bd_addr[0];

                        local_addr->address[0] = local_addr->address[0] & 0xFE; // avoid multicast address
                        valid_bda = TRUE;
                        BTIF_TRACE_DEBUG("Got Factory BDA %02X:%02X:%02X:%02X:%02X:%02X",
                                local_addr->address[0], local_addr->address[1], local_addr->address[2],
                                local_addr->address[3], local_addr->address[4], local_addr->address[5]);
                    }
                    close(vflash_fd);
                }
            }

            /* Get local bdaddr storage path from property */
            if (!valid_bda && property_get(PROPERTY_BT_BDADDR_PATH, val, NULL))                 // 再从"ro.bt.bdaddr_path"属性返回的val值读取蓝牙地址
            {
                int addr_fd;

                BTIF_TRACE_DEBUG("local bdaddr is stored in %s", val);

                if ((addr_fd = open(val, O_RDONLY)) != -1)
                {
                    memset(val, 0, sizeof(val));
                    read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);
                    str2bd(val, local_addr);
                    /* If this is not a reserved/special bda, then use it */
                    if (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0)
                    {
                        valid_bda = TRUE;
                        BTIF_TRACE_DEBUG("Got Factory BDA %02X:%02X:%02X:%02X:%02X:%02X",
                                local_addr->address[0], local_addr->address[1], local_addr->address[2],
                                local_addr->address[3], local_addr->address[4], local_addr->address[5]);
                    }

                    close(addr_fd);
                }
            }

            if(!valid_bda)
            {
                val_size = sizeof(val);
                if(btif_config_get_str("Local", "Adapter", "Address", val, &val_size))          // 再根据"Local", "Adapter", "Address"从bt_config.xml文件中查找蓝牙地址
                {
                    str2bd(val, local_addr);
                    BTIF_TRACE_DEBUG("local bdaddr from bt_config.xml is  %s", val);
                    return;
                }
            }

            /* No factory BDADDR found. Look for previously generated random BDA */
            if ((!valid_bda) && \
                    (property_get(PERSIST_BDADDR_PROPERTY, val, NULL)))                         // 再从"persist.service.bdroid.bdaddr"属性中读取蓝牙地址
            {
                str2bd(val, local_addr);
                valid_bda = TRUE;
                BTIF_TRACE_DEBUG("Got prior random BDA %02X:%02X:%02X:%02X:%02X:%02X",
                        local_addr->address[0], local_addr->address[1], local_addr->address[2],
                        local_addr->address[3], local_addr->address[4], local_addr->address[5]);
            }

            /* Generate new BDA if necessary */
            if (!valid_bda)
            {
                bdstr_t bdstr;
                /* Seed the random number generator */
                srand((unsigned int) (time(0)));                                                // 以上都获取不到蓝牙地址，就随机生成前缀为22:22的蓝牙地址

                /* No autogen BDA. Generate one now. */
                local_addr->address[0] = 0x22;
                local_addr->address[1] = 0x22;
                local_addr->address[2] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[3] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[4] = (uint8_t) ((rand() >> 8) & 0xFF);
                local_addr->address[5] = (uint8_t) ((rand() >> 8) & 0xFF);

                /* Convert to ascii, and store as a persistent property */
                bd2str(local_addr, &bdstr);

                BTIF_TRACE_DEBUG("No preset BDA. Generating BDA: %s for prop %s",
                        (char*)bdstr, PERSIST_BDADDR_PROPERTY);

                if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0)
                    BTIF_TRACE_ERROR("Failed to set random BDA in prop %s",PERSIST_BDADDR_PROPERTY);
            }

            //save the bd address to config file
            bdstr_t bdstr;
            bd2str(local_addr, &bdstr);
            val_size = sizeof(val);
            if (btif_config_get_str("Local", "Adapter", "Address", val, &val_size))
            {
                if (strcmp(bdstr, val) ==0)
                {
                    // BDA is already present in the config file.
                    return;
                }
            }
            btif_config_set_str("Local", "Adapter", "Address", bdstr);
            btif_config_save();                                                                 // 将蓝牙地址写入到bt_config.xml文件中
        }

        bt_status_t btif_init_bluetooth()
        {
            UINT8 status;
            btif_config_init();
            bte_main_boot_entry();                                          // bte主引导进入

            /* As part of the init, fetch the local BD ADDR */
            memset(&btif_local_bd_addr, 0, sizeof(bt_bdaddr_t));
            btif_fetch_local_bdaddr(&btif_local_bd_addr);

            /* start btif task */
            // BTIF task handler managing all messages being passed Bluetooth HAL and BTA.  // btif_task处理所有蓝牙HAL和BTA的消息
            status = GKI_create_task(btif_task, BTIF_TASK, BTIF_TASK_STR,
                    (UINT16 *) ((UINT8 *)btif_task_stack + BTIF_TASK_STACK_SIZE),
                    sizeof(btif_task_stack));

            if (status != GKI_SUCCESS)
                return BT_STATUS_FAIL;

            return BT_STATUS_SUCCESS;
        }

        static void btif_task(UINT32 params)
        {
            BTIF_TRACE_DEBUG("btif task starting");
            btif_associate_evt();

            for(;;)
            {
                /* wait for specified events */
                event = GKI_wait(0xFFFF, 0);

                /*
                 * Wait for the trigger to init chip and stack. This trigger will
                 * be received by btu_task once the UART is opened and ready
                 */
                if (event == BT_EVT_TRIGGER_STACK_INIT)
                {
                    BTIF_TRACE_DEBUG("btif_task: received trigger stack init event");
            #if (BLE_INCLUDED == TRUE)
                    btif_dm_load_ble_local_keys();
            #endif
                    BTA_EnableBluetooth(bte_dm_evt);
                }

                /*
                 * Failed to initialize controller hardware, reset state and bring
                 * down all threads
                 */
                if (event == BT_EVT_HARDWARE_INIT_FAIL)
                {
                    BTIF_TRACE_DEBUG("btif_task: hardware init failed");
                    bte_main_disable();
                    btif_queue_release();
                    GKI_task_self_cleanup(BTIF_TASK);
                    bte_main_shutdown();
                    btif_dut_mode = 0;
                    btif_core_state = BTIF_CORE_STATE_DISABLED;
                    HAL_CBACK(bt_hal_cbacks,adapter_state_changed_cb,BT_STATE_OFF);
                    break;
                }

                if (event & EVENT_MASK(GKI_SHUTDOWN_EVT))
                    break;

                if(event & TASK_MBOX_1_EVT_MASK)
                {
                    while((p_msg = GKI_read_mbox(BTU_BTIF_MBOX)) != NULL)
                    {
                        BTIF_TRACE_VERBOSE("btif task fetched event %x", p_msg->event);

                        switch (p_msg->event)
                        {
                            case BT_EVT_CONTEXT_SWITCH_EVT:
                                btif_context_switched(p_msg);
                                break;
                            default:
                                BTIF_TRACE_ERROR("unhandled btif event (%d)", p_msg->event & BT_EVT_MASK);
                                break;
                        }

                        GKI_freebuf(p_msg);
                    }
                }
            }

            btif_disassociate_evt();

            BTIF_TRACE_DEBUG("btif task exiting");
        }
        ->  {
                /*****************************************************************************
                 **  Constants
                 *****************************************************************************/

                static const tBTA_SYS_REG bta_dm_reg =
                {
                    bta_dm_sm_execute,
                    bta_dm_sm_disable
                };

                static const tBTA_SYS_REG bta_dm_search_reg =
                {
                    bta_dm_search_sm_execute,
                    bta_dm_search_sm_disable
                };

                /*******************************************************************************
                 **
                 ** Function         BTA_EnableBluetooth
                 **
                 ** Description      Enables bluetooth service.  This function must be
                 **                  called before any other functions in the BTA API are called.
                 **
                 **
                 ** Returns          tBTA_STATUS
                 **
                 *******************************************************************************/
                tBTA_STATUS BTA_EnableBluetooth(tBTA_DM_SEC_CBACK *p_cback)
                { 
                    tBTA_DM_API_ENABLE    *p_msg;

                    /* Bluetooth disabling is in progress */
                    if (bta_dm_cb.disabling)
                        return BTA_FAILURE;

                    memset(&bta_dm_cb, 0, sizeof(bta_dm_cb));

                    bta_sys_register (BTA_ID_DM, &bta_dm_reg );                     // 注册BTA_ID_DM处理函数
                    bta_sys_register (BTA_ID_DM_SEARCH, &bta_dm_search_reg );       // 注册BTA_ID_DM_SEARCH处理函数

                    /* if UUID list is not provided as static data */
                    bta_sys_eir_register(bta_dm_eir_update_uuid);

                    if ((p_msg = (tBTA_DM_API_ENABLE *) GKI_getbuf(sizeof(tBTA_DM_API_ENABLE))) != NULL)
                    {
                        p_msg->hdr.event = BTA_DM_API_ENABLE_EVT;
                        p_msg->p_sec_cback = p_cback;
                        bta_sys_sendmsg(p_msg);
                        return BTA_SUCCESS;
                    }
                    return BTA_FAILURE;

                }
            }

        bt_status_t btif_enable_bluetooth(void)
        {
            BTIF_TRACE_DEBUG("BTIF ENABLE BLUETOOTH");

            if (btif_core_state != BTIF_CORE_STATE_DISABLED)
            {
                ALOGD("not disabled\n");
                return BT_STATUS_DONE;
            }

            btif_core_state = BTIF_CORE_STATE_ENABLING;

            /* Create the GKI tasks and run them */
            bte_main_enable();

            return BT_STATUS_SUCCESS;
        }
    }
-------------------------------------------------------------------------------------------------------->
Bta_dm_main.c (external\bluetooth\bluedroid\bta\dm)
->  {
        /* action function list */
        const tBTA_DM_ACTION bta_dm_action[] =
        {

            /* device manager local device API events */
            bta_dm_enable,            /* 0  BTA_DM_API_ENABLE_EVT */
            bta_dm_disable,           /* 1  BTA_DM_API_DISABLE_EVT */
            bta_dm_set_dev_name,      /* 2  BTA_DM_API_SET_NAME_EVT */
            bta_dm_set_visibility,    /* 3  BTA_DM_API_SET_VISIBILITY_EVT */
            bta_dm_set_afhchannels,   /* 4  BTA_DM_API_SET_AFH_CHANNELS_EVT */
            bta_dm_signal_strength,   /* 5  BTA_API_DM_SIG_STRENGTH_EVT */
            bta_dm_vendor_spec_command,/* 6  BTA_DM_API_VENDOR_SPECIFIC_COMMAND_EVT */
            bta_dm_tx_inqpower,       /* 7  BTA_DM_API_SIG_STRENGTH_EVT */
            bta_dm_acl_change,        /* 8  BTA_DM_ACL_CHANGE_EVT */
            bta_dm_add_device,        /* 9  BTA_DM_API_ADD_DEVICE_EVT */
            bta_dm_close_acl,         /* 10 BTA_DM_API_ADD_DEVICE_EVT */

            /* security API events */
            bta_dm_bond,              /* 11  BTA_DM_API_BOND_EVT */
            bta_dm_bond_cancel,       /* 12  BTA_DM_API_BOND_CANCEL_EVT */
            bta_dm_pin_reply,         /* 13 BTA_DM_API_PIN_REPLY_EVT */
            bta_dm_link_policy,       /* 14 BTA_DM_API_LINK_POLICY_EVT */
            bta_dm_auth_reply,        /* 15 BTA_DM_API_AUTH_REPLY_EVT */

            /* power manger events */
            bta_dm_pm_btm_status,     /* 16 BTA_DM_PM_BTM_STATUS_EVT */
            bta_dm_pm_timer,          /* 17 BTA_DM_PM_TIMER_EVT*/

            /* simple pairing events */
            bta_dm_confirm,           /* 18 BTA_DM_API_CONFIRM_EVT */

            bta_dm_set_encryption,    /* BTA_DM_API_SET_ENCRYPTION_EVT */

        #if (BTM_LOCAL_IO_CAPS != BTM_IO_CAP_NONE)
            bta_dm_passkey_cancel,    /* 19 BTA_DM_API_PASKY_CANCEL_EVT */
        #endif
        #if (BTM_OOB_INCLUDED == TRUE)
            bta_dm_loc_oob,           /* 20 BTA_DM_API_LOC_OOB_EVT */
            bta_dm_ci_io_req_act,     /* 21 BTA_DM_CI_IO_REQ_EVT */
            bta_dm_ci_rmt_oob_act,    /* 22 BTA_DM_CI_RMT_OOB_EVT */
        #endif /* BTM_OOB_INCLUDED */

            bta_dm_remove_device,      /*  BTA_DM_API_REMOVE_DEVICE_EVT */

        #if BLE_INCLUDED == TRUE
            bta_dm_add_blekey,          /*  BTA_DM_API_ADD_BLEKEY_EVT           */
            bta_dm_add_ble_device,      /*  BTA_DM_API_ADD_BLEDEVICE_EVT        */
            bta_dm_ble_passkey_reply,   /*  BTA_DM_API_BLE_PASSKEY_REPLY_EVT    */
            bta_dm_security_grant,
            bta_dm_ble_set_bg_conn_type,
            bta_dm_ble_set_conn_params,      /* BTA_DM_API_BLE_CONN_PARAM_EVT */
            bta_dm_ble_set_scan_params,      /* BTA_DM_API_BLE_SCAN_PARAM_EVT */
            bta_dm_ble_observe,
            bta_dm_ble_update_conn_params,   /* BTA_DM_API_UPDATE_CONN_PARAM_EVT */
        #if BLE_PRIVACY_SPT == TRUE
            bta_dm_ble_config_local_privacy,   /* BTA_DM_API_LOCAL_PRIVACY_EVT */
        #endif
            bta_dm_ble_set_adv_params,     /* BTA_DM_API_BLE_SCAN_PARAM_EVT */
            bta_dm_ble_set_adv_config,     /* BTA_DM_API_BLE_SET_ADV_CONFIG_EVT */
            bta_dm_ble_set_scan_rsp,       /* BTA_DM_API_BLE_SET_SCAN_RSP_EVT */
            bta_dm_ble_broadcast,          /* BTA_DM_API_BLE_BROADCAST_EVT */
        #if BLE_ANDROID_CONTROLLER_SCAN_FILTER == TRUE
            bta_dm_cfg_filter_cond,         /* BTA_DM_API_CFG_FILTER_COND_EVT */
            bta_dm_scan_filter_param_setup, /* BTA_DM_API_SCAN_FILTER_SETUP_EVT */
            bta_dm_enable_scan_filter,      /* BTA_DM_API_SCAN_FILTER_ENABLE_EVT */
        #endif
            bta_dm_ble_multi_adv_enb,           /*  BTA_DM_API_BLE_MULTI_ADV_ENB_EVT*/
            bta_dm_ble_multi_adv_upd_param,     /*  BTA_DM_API_BLE_MULTI_ADV_PARAM_UPD_EVT */
            bta_dm_ble_multi_adv_data,          /*  BTA_DM_API_BLE_MULTI_ADV_DATA_EVT */
            btm_dm_ble_multi_adv_disable,       /*  BTA_DM_API_BLE_MULTI_ADV_DISABLE_EVT */
            bta_dm_ble_setup_storage,      /* BTA_DM_API_BLE_SETUP_STORAGE_EVT */
            bta_dm_ble_enable_batch_scan,  /* BTA_DM_API_BLE_ENABLE_BATCH_SCAN_EVT */
            bta_dm_ble_disable_batch_scan, /* BTA_DM_API_BLE_DISABLE_BATCH_SCAN_EVT */
            bta_dm_ble_read_scan_reports,  /* BTA_DM_API_BLE_READ_SCAN_REPORTS_EVT */
            bta_dm_ble_track_advertiser,   /* BTA_DM_API_BLE_TRACK_ADVERTISER_EVT */
            bta_dm_ble_get_energy_info,    /* BTA_DM_API_BLE_ENERGY_INFO_EVT */
        #endif

        #if ( BTM_EIR_SERVER_INCLUDED == TRUE )&&( BTA_EIR_CANNED_UUID_LIST != TRUE )&&(BTA_EIR_SERVER_NUM_CUSTOM_UUID > 0)
            bta_dm_update_eir_uuid,     /*  BTA_DM_API_UPDATE_EIR_UUID_EVT      */
        #endif
        #if (BTM_EIR_SERVER_INCLUDED == TRUE)
            bta_dm_set_eir_config,      /*  BTA_DM_API_SET_EIR_CONFIG_EVT       */
        #endif

            bta_dm_enable_test_mode,    /*  BTA_DM_API_ENABLE_TEST_MODE_EVT     */
            bta_dm_disable_test_mode,   /*  BTA_DM_API_DISABLE_TEST_MODE_EVT    */
            bta_dm_execute_callback,     /*  BTA_DM_API_EXECUTE_CBACK_EVT        */
            bta_dm_set_afh_channel_assesment      /* BTA_DM_API_SET_AFH_CHANNEL_ASSESMENT_EVT */
        };

        /* action function list */
        const tBTA_DM_ACTION bta_dm_search_action[] =
        {

            bta_dm_search_start,              /* 0 BTA_DM_API_SEARCH */
            bta_dm_search_cancel,             /* 1 BTA_DM_API_SEARCH_CANCEL */
            bta_dm_discover,                  /* 2 BTA_DM_API_DISCOVER */
            bta_dm_inq_cmpl,                  /* 3 BTA_DM_INQUIRY_CMPL */
            bta_dm_rmt_name,                  /* 4 BTA_DM_REMT_NAME */
            bta_dm_sdp_result,                /* 5 BTA_DM_SDP_RESULT */
            bta_dm_search_cmpl,               /* 6 BTA_DM_SEARCH_CMPL */
            bta_dm_free_sdp_db,               /* 7 BTA_DM_FREE_SDP_DB */
            bta_dm_disc_result,               /* 8 BTA_DM_DISC_RESULT */
            bta_dm_search_result,             /* 9 BTA_DM_SEARCH_RESULT */
            bta_dm_queue_search,              /* 10 BTA_DM_QUEUE_SEARCH */
            bta_dm_queue_disc,                /* 11 BTA_DM_QUEUE_DISC */
            bta_dm_search_clear_queue,        /* 12 BTA_DM_SEARCH_CLEAR_QUEUE */
            bta_dm_search_cancel_cmpl,        /* 13 BTA_DM_SEARCH_CANCEL_CMPL */
            bta_dm_search_cancel_notify,      /* 14 BTA_DM_SEARCH_CANCEL_NOTIFY */
            bta_dm_search_cancel_transac_cmpl, /* 15 BTA_DM_SEARCH_CANCEL_TRANSAC_CMPL */
            bta_dm_disc_rmt_name,             /* 16 BTA_DM_DISC_RMT_NAME */
            bta_dm_di_disc                    /* 17 BTA_DM_API_DI_DISCOVER */
        #if BLE_INCLUDED == TRUE
                ,bta_dm_close_gatt_conn
        #endif
        };

        /* state table */
        const tBTA_DM_ST_TBL bta_dm_search_st_tbl[] = {
            bta_dm_search_idle_st_table,
            bta_dm_search_search_active_st_table,
            bta_dm_search_search_cancelling_st_table,
            bta_dm_search_disc_active_st_table
        };

        /*******************************************************************************
         **
         ** Function         bta_dm_sm_execute
         **
         ** Description      State machine event handling function for DM
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BOOLEAN bta_dm_sm_execute(BT_HDR *p_msg)
        {
            UINT16  event = p_msg->event & 0x00ff;

            APPL_TRACE_EVENT("bta_dm_sm_execute event:0x%x", event);

            /* execute action functions */
            if(event < BTA_DM_NUM_ACTIONS)
            {
                (*bta_dm_action[event])( (tBTA_DM_MSG*) p_msg);
            }

            return TRUE;
        }

        /*******************************************************************************
         **
         ** Function         bta_dm_search_sm_execute
         **
         ** Description      State machine event handling function for DM
         **
         **
         ** Returns          void
         **
         *******************************************************************************/
        BOOLEAN bta_dm_search_sm_execute(BT_HDR *p_msg)
        {
            tBTA_DM_ST_TBL      state_table;
            UINT8               action;
            int                 i;

            APPL_TRACE_EVENT("bta_dm_search_sm_execute state:%d, event:0x%x",
                    bta_dm_search_cb.state, p_msg->event);

            /* look up the state table for the current state */
            state_table = bta_dm_search_st_tbl[bta_dm_search_cb.state];

            bta_dm_search_cb.state = state_table[p_msg->event & 0x00ff][BTA_DM_SEARCH_NEXT_STATE];


            /* execute action functions */
            for (i = 0; i < BTA_DM_SEARCH_ACTIONS; i++)
            {
                if ((action = state_table[p_msg->event & 0x00ff][i]) != BTA_DM_SEARCH_IGNORE)
                {
                    (*bta_dm_search_action[action])( (tBTA_DM_MSG*) p_msg);
                }
                else
                {
                    break;
                }
            }
            return TRUE;
        }
    }
-------------------------------------------------------------------------------------------------------->
Btif_config.c (external\bluetooth\bluedroid\btif\src)
->  {
        #define CFG_PATH "/data/misc/bluedroid/"
        #define CFG_FILE_NAME "bt_config"
        #define CFG_FILE_EXT ".xml"
        #define CFG_FILE_EXT_OLD ".old"
        #define CFG_FILE_EXT_NEW ".new"
        
        static int save_cfg()
        {
            const char* file_name = CFG_PATH CFG_FILE_NAME CFG_FILE_EXT;                // file_name = "/data/misc/bluedroid/bt_config.xml"
            const char* file_name_new = CFG_PATH CFG_FILE_NAME CFG_FILE_EXT_NEW;        // file_name_new = "/data/misc/bluedroid/bt_config.new"
            const char* file_name_old = CFG_PATH CFG_FILE_NAME CFG_FILE_EXT_OLD;        // file_name_old = "/data/misc/bluedroid/bt_config.old"

            int ret = FALSE;
            if(access(file_name_old,  F_OK) == 0)
                unlink(file_name_old);
            if(access(file_name_new, F_OK) == 0)
                unlink(file_name_new);
            if(btif_config_save_file(file_name_new))
            {
                cached_change = 0;
                chown(file_name_new, -1, AID_NET_BT_STACK);
                chmod(file_name_new, 0660);
                rename(file_name, file_name_old);
                rename(file_name_new, file_name);
                ret = TRUE;
            }
            else bdle("btif_config_save_file failed");
            return ret;
        }

        static void cfg_cmd_callback(int cmd_fd, int type, int size, uint32_t user_id)
        {
            switch(type)
            {
                case CFG_CMD_SAVE:
                    {
                        if(cached_change > 0)
                            save_cfg();
                        break;
                    }
            }
        }

        int btif_config_init()
        {
            static int initialized;
            bdld("in initialized:%d", initialized);
            if(!initialized)
            {
                initialized = 1;
                struct stat st;
                if(stat(CFG_PATH, &st) != 0)                                    
                    bdle("%s does not exist, need provision", CFG_PATH);
                btsock_thread_init();                                           // 线程初始化
                init_slot_lock(&slot_lock);
                lock_slot(&slot_lock);
                root.name = "Bluedroid";
                alloc_node(&root, CFG_GROW_SIZE);
                dump_node("root", &root);
                pth = btsock_thread_create(NULL, cfg_cmd_callback);             // 创建线程
                load_cfg();
                unlock_slot(&slot_lock);
#ifdef UNIT_TEST
                cfg_test_write();
                //cfg_test_read();
                exit(0);
#endif
            }
            return pth >= 0;
        }
    }
--------------------------------------------------------------------------------------------------------->
Btif_sock_thread.c (external\bluetooth\bluedroid\btif\src)
->  {
        int btsock_thread_init()
        {
            static int initialized;
            APPL_TRACE_DEBUG("in initialized:%d", initialized);
            if(!initialized)
            {
                initialized = 1;
                init_slot_lock(&thread_slot_lock);
                int h;
                for(h = 0; h < MAX_THREAD; h++)
                {
                    ts[h].cmd_fdr = ts[h].cmd_fdw = -1;
                    ts[h].used = 0;
                    ts[h].thread_id = -1;
                    ts[h].poll_count = 0;
                    ts[h].callback = NULL;
                    ts[h].cmd_callback = NULL;
                }
            }
            return TRUE;
        }

        int btsock_thread_create(btsock_signaled_cb callback, btsock_cmd_cb cmd_callback)
        {
            int ret = FALSE;
            asrt(callback || cmd_callback);
            lock_slot(&thread_slot_lock);
            int h = alloc_thread_slot();
            unlock_slot(&thread_slot_lock);
            APPL_TRACE_DEBUG("alloc_thread_slot ret:%d", h);
            if(h >= 0)
            {
                init_poll(h);
                if((ts[h].thread_id = create_thread(sock_poll_thread, (void*)(uintptr_t)h)) != -1)
                {
                    APPL_TRACE_DEBUG("h:%d, thread id:%d", h, ts[h].thread_id);
                    ts[h].callback = callback;
                    ts[h].cmd_callback = cmd_callback;
                }
                else
                {
                    free_thread_slot(h);
                    h = -1;
                }
            }
            return h;
        }
        ->  {
                static void *sock_poll_thread(void *arg)
                {
                    struct pollfd pfds[MAX_POLL];
                    memset(pfds, 0, sizeof(pfds));
                    int h = (intptr_t)arg;
                    for(;;)
                    {
                        prepare_poll_fds(h, pfds);
                        int ret = poll(pfds, ts[h].poll_count, -1);
                        if(ret == -1)
                        {
                            APPL_TRACE_ERROR("poll ret -1, exit the thread, errno:%d, err:%s", errno, strerror(errno));
                            break;
                        }
                        if(ret != 0)
                        {
                            int need_process_data_fd = TRUE;
                            if(pfds[0].revents) //cmd fd always is the first one
                            {
                                asrt(pfds[0].fd == ts[h].cmd_fdr);
                                if(!process_cmd_sock(h))                                                    // 处理命令的函数, 回调cmd_callback函数
                                {
                                    APPL_TRACE_DEBUG("h:%d, process_cmd_sock return false, exit...", h);
                                    break;
                                }
                                if(ret == 1)
                                    need_process_data_fd = FALSE;
                                else ret--; //exclude the cmd fd
                            }
                            if(need_process_data_fd)
                                process_data_sock(h, pfds, ret);                                            // 处理数据的函数，回调callback函数
                        }
                        else {APPL_TRACE_DEBUG("no data, select ret: %d", ret)};
                    }
                    ts[h].thread_id = -1;
                    APPL_TRACE_DEBUG("socket poll thread exiting, h:%d", h);
                    return 0;
                }
            }
    }
--------------------------------------------------------------------------------------------------------->
Bte_main.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\main)
->  {
        /******************************************************************************
         **
         ** Function         bte_main_boot_entry
         **
         ** Description      BTE MAIN API - Entry point for BTE chip/stack initialization
         **
         ** Returns          None
         **
         ******************************************************************************/
        void bte_main_boot_entry(void)
        {
            /* initialize OS */
            GKI_init();

            bte_main_in_hw_init();

            bte_load_conf(BTE_STACK_CONF_FILE);                             // 默认是"/etc/bluetooth/bt_stack.conf"
        #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))               // 默认是"/etc/bluetooth/ble_stack.conf"
            bte_load_ble_conf(BTE_BLE_STACK_CONF_FILE);
        #endif

        #if (BTTRC_INCLUDED == TRUE)
            /* Initialize trace feature */
            BTTRC_TraceInit(MAX_TRACE_RAM_SIZE, &BTE_TraceLogBuf[0], BTTRC_METHOD_RAM);
        #endif

            pthread_mutex_init(&cleanup_lock, NULL);

        }

        /******************************************************************************
         **
         ** Function         bte_main_in_hw_init
         **
         ** Description      Internal helper function for chip hardware init
         **
         ** Returns          None
         **
         ******************************************************************************/
        static void bte_main_in_hw_init(void)
        {
            if ( (bt_hc_if = (bt_hc_interface_t *) bt_hc_get_interface()) \                 // 获取hci控制接口
                    == NULL)
            {
                APPL_TRACE_ERROR("!!! Failed to get BtHostControllerInterface !!!");
            }

            memset(&preload_retry_cb, 0, sizeof(bt_preload_retry_cb_t));
        }

        void bte_main_enable()
        {
            APPL_TRACE_DEBUG("%s", __FUNCTION__);

            /* Initialize BTE control block */
            BTE_Init();                                                         // 初始化BTE控制块

            lpm_enabled = FALSE;

            GKI_create_task((TASKPTR)btu_task, BTU_TASK, BTE_BTU_TASK_STR,
                    (UINT16 *) ((UINT8 *)bte_btu_stack + BTE_BTU_STACK_SIZE),
                    sizeof(bte_btu_stack));

            bte_hci_enable();                                                   // BTE hci使能

            GKI_run();
        }
    }
    ->  {
            static void bte_hci_enable(void)
            {
                APPL_TRACE_DEBUG("%s", __FUNCTION__);

                preload_start_wait_timer();

                if (bt_hc_if)
                {
                    int result = bt_hc_if->init(&hc_callbacks, btif_local_bd_addr.address);
                    APPL_TRACE_EVENT("libbt-hci init returns %d", result);

                    assert(result == BT_HC_STATUS_SUCCESS);

                    if (hci_logging_enabled == TRUE || hci_logging_config == TRUE)
                        bt_hc_if->logging(BT_HC_LOGGING_ON, hci_logfile, hci_save_log);

                #if (defined (BT_CLEAN_TURN_ON_DISABLED) && BT_CLEAN_TURN_ON_DISABLED == TRUE)
                    APPL_TRACE_DEBUG("%s  Not Turninig Off the BT before Turninig ON", __FUNCTION__);

                    /* Do not power off the chip before powering on  if BT_CLEAN_TURN_ON_DISABLED flag
                       is defined and set to TRUE to avoid below mentioned issue.

                       Wingray kernel driver maintains a combined  counter to keep track of
                       BT-Wifi state. Invoking  set_power(BT_HC_CHIP_PWR_OFF) when the BT is already
                       in OFF state causes this counter to be incorrectly decremented and results in undesired
                       behavior of the chip.

                       This is only a workaround and when the issue is fixed in the kernel this work around
                       should be removed. */
                #else
                    /* toggle chip power to ensure we will reset chip in case
                       a previous stack shutdown wasn't completed gracefully */
                    bt_hc_if->set_power(BT_HC_CHIP_PWR_OFF);
                #endif
                    bt_hc_if->set_power(BT_HC_CHIP_PWR_ON);

                    bt_hc_if->preload(NULL);
                }
            }
        }
-------------------------------------------------------------------------------------------------------->
Btu_init.c (external\bluetooth\bluedroid\stack\btu)	4627	11/19/2018
->  {
        #define BTU_DEFAULT_DATA_SIZE (0x2a0)

        #if (BLE_INCLUDED == TRUE)
        #define BTU_DEFAULT_BLE_DATA_SIZE   (27)
        #endif

        #define HCI_DATA_PREAMBLE_SIZE  4

        /*****************************************************************************
         **
         ** Function         BTE_Init
         **
         ** Description      Initializes the BTU control block.
         **
         **                  NOTE: Must be called before creating any tasks
         **                      (RPC, BTU, HCIT, APPL, etc.)
         **
         ** Returns          void
         **
         ******************************************************************************/
        void BTE_Init(void)
        {
            int i = 0;

            memset (&btu_cb, 0, sizeof (tBTU_CB));
            btu_cb.hcit_acl_pkt_size = BTU_DEFAULT_DATA_SIZE + HCI_DATA_PREAMBLE_SIZE;              // 配置acl packet size
#if (BLE_INCLUDED == TRUE)
            btu_cb.hcit_ble_acl_pkt_size = BTU_DEFAULT_BLE_DATA_SIZE + HCI_DATA_PREAMBLE_SIZE;      // 配置ble acl packet size
#endif
            btu_cb.trace_level = HCI_INITIAL_TRACE_LEVEL;

            for ( i = 0; i < BTU_MAX_LOCAL_CTRLS; i++ ) /* include BR/EDR */
                btu_cb.hci_cmd_cb[i].cmd_window = 1;
        }

        void btu_init_core(void)
        {
            /* Initialize the mandatory core stack components */
            btm_init();

            l2c_init();

            sdp_init();

#if BLE_INCLUDED == TRUE
            gatt_init();
#if (defined(SMP_INCLUDED) && SMP_INCLUDED == TRUE)
            SMP_Init();
#endif
            btm_ble_init();
#endif
        }
    }
-------------------------------------------------------------------------------------------------------->
Btu_task.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\stack\btu)
->  {
        BTU_API UINT32 btu_task (UINT32 param) {
            /* Initialize the mandatory core stack control blocks
               (BTU, BTM, L2CAP, and SDP)
             */
            btu_init_core();

            /* Initialize any optional stack components */
            BTE_InitStack();                                                    // 初始化bt stack协议栈

        #if (defined(BTU_BTA_INCLUDED) && BTU_BTA_INCLUDED == TRUE)
            bta_sys_init();
        #endif

        #if ( BT_USE_TRACES==TRUE )
            BTE_InitTraceLevels();
        #endif

            /* Send a startup evt message to BTIF_TASK to kickstart the init procedure */
            GKI_send_event(BTIF_TASK, BT_EVT_TRIGGER_STACK_INIT);               // 向btif_task发送BT_EVT_TRIGGER_STACK_INIT消息

            prctl(PR_SET_NAME, (unsigned long)"BTU TASK", 0, 0, 0);

            raise_priority_a2dp(TASK_HIGH_BTU);                                 // 提高A2DP优先级！

            /* Wait for, and process, events */
            for (;;) {
                // 待研究...
            }
        }
    }
-------------------------------------------------------------------------------------------------------->
Bte_init.c (external\bluetooth\bluedroid\main)
->  {
        /*****************************************************************************
         **
         ** Function         BTE_InitStack
         **
         ** Description      Initialize control block memory for each component.
         **
         **                  Note: The core stack components must be called
         **                      before creating the BTU Task.  The rest of the
         **                      components can be initialized at a later time if desired
         **                      as long as the component's init function is called
         **                      before accessing any of its functions.
         **
         ** Returns          void
         **
         ******************************************************************************/
        BT_API void BTE_InitStack(void)
        {
            /* Initialize the optional stack components */

            /****************************
             ** RFCOMM and its profiles **
             *****************************/
#if (defined(RFCOMM_INCLUDED) && RFCOMM_INCLUDED == TRUE)
            RFCOMM_Init();

#if (defined(SPP_INCLUDED) && SPP_INCLUDED == TRUE)
            SPP_Init();
#endif  /* SPP */

#if (defined(DUN_INCLUDED) && DUN_INCLUDED == TRUE)
            DUN_Init();
#endif  /* DUN */

#if (defined(HSP2_INCLUDED) && HSP2_INCLUDED == TRUE)
            HSP2_Init();
#endif  /* HSP2 */

#if (defined(HFP_INCLUDED) && HFP_INCLUDED == TRUE)
            HFP_Init();
#endif  /* HFP */

            /**************************
             ** OBEX and its profiles **
             ***************************/
#if (defined(OBX_INCLUDED) && OBX_INCLUDED == TRUE)
            OBX_Init();
#if (defined(BIP_INCLUDED) && BIP_INCLUDED == TRUE)
            BIP_Init();
#if (defined(BTU_BTA_INCLUDED) && BTU_BTA_INCLUDED == TRUE)
#if (defined(BTA_BI_INCLUDED) && BTA_BI_INCLUDED == TRUE)
            BTA_BicInit();
#endif  /* BTA BI */
#endif
#endif  /* BIP */

#if (defined(GOEP_INCLUDED) && GOEP_INCLUDED == TRUE)
            GOEP_Init();
#endif /* GOEP */


#if (defined(FTP_INCLUDED) && FTP_INCLUDED == TRUE)
            FTP_Init();
#endif
#if (defined(OPP_INCLUDED) && OPP_INCLUDED == TRUE)
            OPP_Init();
#endif

#if (defined(BPP_INCLUDED) && BPP_INCLUDED == TRUE)
            BPP_Init();
#endif  /* BPP */
#endif  /* OBX */


#endif  /* RFCOMM Included */

            /*************************
             ** TCS and its profiles **
             **************************/
#if (defined(TCS_INCLUDED) && TCS_INCLUDED == TRUE)
            TCS_Init();

#if (defined(CTP_INCLUDED) && CTP_INCLUDED == TRUE)
            CTP_Init();
#endif /* CTP_INCLUDED */

#if (defined(ICP_INCLUDED) && ICP_INCLUDED == TRUE)
            ICP_Init();
#endif /* ICP_INCLUDED */

#endif /* TCS_INCLUDED */


            /**************************
             ** BNEP and its profiles **
             ***************************/
#if (defined(BNEP_INCLUDED) && BNEP_INCLUDED == TRUE)
            BNEP_Init();

#if (defined(PAN_INCLUDED) && PAN_INCLUDED == TRUE)
            PAN_Init();
#endif  /* PAN */
#endif  /* BNEP Included */


            /**************************
             ** AVDT and its profiles **
             ***************************/
#if (defined(A2D_INCLUDED) && A2D_INCLUDED == TRUE)
            A2D_Init();
#endif  /* AADP */


#if (defined(AVRC_INCLUDED) && AVRC_INCLUDED == TRUE)
            AVRC_Init();
#endif


            /***********
             ** Others **
             ************/
#if (defined(GAP_INCLUDED) && GAP_INCLUDED == TRUE)
            GAP_Init();
#endif  /* GAP Included */

#if (defined(HCRP_INCLUDED) && HCRP_INCLUDED == TRUE)
#if (defined(HCRP_CLIENT_INCLUDED) && HCRP_CLIENT_INCLUDED == TRUE)
            HCRP_Init();
#endif
#if (defined(HCRP_SERVER_INCLUDED) && HCRP_SERVER_INCLUDED == TRUE)
            HCRPM_Init();
#endif
#endif  /* HCRP Included */

#if (defined(SAP_SERVER_INCLUDED) && SAP_SERVER_INCLUDED == TRUE)
            SAP_Init();
#endif  /* SAP_SERVER_INCLUDED */

#if (defined(HID_DEV_INCLUDED) && HID_DEV_INCLUDED == TRUE)
            HID_DevInit();
#endif
#if (defined(HID_HOST_INCLUDED) && HID_HOST_INCLUDED == TRUE)
            HID_HostInit();
#endif

#if (defined(MCA_INCLUDED) && MCA_INCLUDED == TRUE)
            MCA_Init();
#endif  /* SAP_SERVER_INCLUDED */
        }
    }
---------------------------------------------------------------------------------------------------------->
Bt_hci_bdroid.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        static const bt_hc_interface_t bluetoothHCLibInterface = {
            sizeof(bt_hc_interface_t),
            init,
            set_power,
            lpm,
            preload,
            postload,
            transmit_buf,
            logging,
            cleanup,
            tx_hc_cmd,
        };

        /*******************************************************************************
         **
         ** Function        bt_hc_get_interface
         **
         ** Description     Caller calls this function to get API instance
         **
         ** Returns         API table
         **
         *******************************************************************************/
        const bt_hc_interface_t *bt_hc_get_interface(void)
        {
            return &bluetoothHCLibInterface;
        }

        static int init(const bt_hc_callbacks_t* p_cb, unsigned char *local_bdaddr)
        {
            vendor_open(local_bdaddr);

            p_hci_if = &hci_h4_func_table;
            p_hci_if->init();

            userial_init();
            lpm_init();

            // Set prio here and let hci worker thread inherit prio
            // remove once new thread api (thread_set_priority() ?)
            // can switch prio
            raise_priority_a2dp(TASK_HIGH_HCI_WORKER);

            hc_cb.worker_thread = thread_new("bt_hc_worker");
        }

        /** Chip power control */
        static void set_power(bt_hc_chip_power_state_t state)
        {
            int pwr_state;

            BTHCDBG("set_power %d", state);

            /* Calling vendor-specific part */
            pwr_state = (state == BT_HC_CHIP_PWR_ON) ? BT_VND_PWR_ON : BT_VND_PWR_OFF;

            vendor_send_command(BT_VND_OP_POWER_CTRL, &pwr_state);
        }

        /** Called prior to stack initialization */
        static void preload(UNUSED_ATTR TRANSAC transac) {
            thread_post(hc_cb.worker_thread, event_preload, NULL);
        }
        ->  {
                static void event_preload(UNUSED_ATTR void *context) {
                    userial_open(USERIAL_PORT_1);
                    vendor_send_command(BT_VND_OP_FW_CFG, NULL);
                }
            }
    }
------------------------------------------------------------------------------------------------------->
Hci_h4.c (external\bluetooth\bluedroid\hci\src)
->  {
        /******************************************************************************
         **  HCI H4 Services interface table
         ******************************************************************************/

        const tHCI_IF hci_h4_func_table =
        {
            hci_h4_init,
            hci_h4_cleanup,
            hci_h4_send_msg,
            hci_h4_send_int_cmd,
            hci_h4_get_acl_data_length,
            hci_h4_receive_msg
        };

        void hci_h4_init(void)
        {
            HCIDBG("hci_h4_init");

            memset(&h4_cb, 0, sizeof(tHCI_H4_CB));
            utils_queue_init(&(h4_cb.acl_rx_q));

            /* Per HCI spec., always starts with 1 */
            num_hci_cmd_pkts = 1;

            /* Give an initial values of Host Controller's ACL data packet length
             * Will update with an internal HCI(_LE)_Read_Buffer_Size request
             */
            h4_cb.hc_acl_data_size = 1021;
            h4_cb.hc_ble_acl_data_size = 27;
        }
    }
------------------------------------------------------------------------------------------------------->
Vendor.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
        static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";

        static const bt_vendor_callbacks_t vendor_callbacks = {
            sizeof(vendor_callbacks),
            firmware_config_cb,
            sco_config_cb,
            low_power_mode_cb,
            sco_audiostate_cb,
            buffer_alloc,
            buffer_free,
            transmit_cb,
            epilog_cb
        };

        bool vendor_open(const uint8_t *local_bdaddr) {
            strcpy(vendor_so, VENDOR_LIBRARY_NAME);
            ALOGD("%s load %s", __func__, vendor_so);

            lib_handle = dlopen(vendor_so, RTLD_NOW);

            vendor_interface = (bt_vendor_interface_t *)dlsym(lib_handle, VENDOR_LIBRARY_SYMBOL_NAME);
            if (!vendor_interface) {
                ALOGE("%s unable to find symbol %s in %s: %s", __func__, VENDOR_LIBRARY_SYMBOL_NAME, vendor_so, dlerror());
                goto error;
            }

            int status = vendor_interface->init(&vendor_callbacks, (unsigned char *)local_bdaddr);
            if (status) {
                ALOGE("%s unable to initialize vendor library: %d", __func__, status);
                goto error;
            }

            return true;
        }       

        int vendor_send_command(bt_vendor_opcode_t opcode, void *param) {
            return vendor_interface->op(opcode, param);
        }
    }
---------------------------------------------------------------------------------------------------------->
Bt_vendor_brcm.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        // Entry point of DLib
        const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
            sizeof(bt_vendor_interface_t),
            init,
            op,
            cleanup
        };
        
        static int init(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr)
        {
        #if (VENDOR_LIB_RUNTIME_TUNING_ENABLED == TRUE)
            ALOGW("*****************************************************************");
            ALOGW("*****************************************************************");
            ALOGW("** Warning - BT Vendor Lib is loaded in debug tuning mode!");
            ALOGW("**");
            ALOGW("** If this is not intentional, rebuild libbt-vendor.so ");
            ALOGW("** with VENDOR_LIB_RUNTIME_TUNING_ENABLED=FALSE and ");
            ALOGW("** check if any run-time tuning parameters needed to be");
            ALOGW("** carried to the build-time configuration accordingly.");
            ALOGW("*****************************************************************");
            ALOGW("*****************************************************************");
        #endif

            userial_vendor_init();
            upio_init();

            vnd_load_conf(VENDOR_LIB_CONF_FILE);                        // 默认是"/etc/bluetooth/bt_vendor.conf", 解析并执行相应函数

            /* store reference to user callbacks */
            bt_vendor_cbacks = (bt_vendor_callbacks_t *) p_cb;          // 保存回调

            /* This is handed over from the stack */
            memcpy(vnd_local_bd_addr, local_bdaddr, 6);

            return 0;
        }

        static int op(bt_vendor_opcode_t opcode, void *param)
        {
            int retval = 0;

            BTVNDDBG("op for %d", opcode);

            switch(opcode)
            {
                case BT_VND_OP_POWER_CTRL:
                    {
                        int *state = (int *) param;
                        if (*state == BT_VND_PWR_OFF)
                            upio_set_bluetooth_power(UPIO_BT_POWER_OFF);
                        else if (*state == BT_VND_PWR_ON)
                        {
                            upio_set_bluetooth_power(UPIO_BT_POWER_ON);
                            BTVNDDBG("Delay for a while after BT power on");
                            usleep(200000);

                        }
                    }
                    break;

                // Must call fwcfg_cb to notify the stack of the completion of vendor specific initialization once it has been done.
                case BT_VND_OP_FW_CFG:
                    {
                        hw_config_start();
                    }
                    break;

                case BT_VND_OP_USERIAL_OPEN:
                    {
                        int (*fd_array)[] = (int (*)[]) param;
                        int fd, idx;
                        fd = userial_vendor_open((tUSERIAL_CFG *) &userial_init_cfg);
                        if (fd != -1)
                        {
                            for (idx=0; idx < CH_MAX; idx++)
                                (*fd_array)[idx] = fd;

                            retval = 1;
                        }
                        /* retval contains numbers of open fd of HCI channels */
                    }
                    break;
            }

            static const tUSERIAL_CFG userial_init_cfg =
            {
                (USERIAL_DATABITS_8 | USERIAL_PARITY_NONE | USERIAL_STOPBITS_1),
                USERIAL_BAUD_115200
            };

            int userial_vendor_open(tUSERIAL_CFG *p_cfg)
            {
                uint32_t baud;
                uint8_t data_bits;
                uint16_t parity;
                uint8_t stop_bits;

                vnd_userial.fd = -1;

                if (!userial_to_tcio_baud(p_cfg->baud, &baud))
                {
                    return -1;
                }

                if(p_cfg->fmt & USERIAL_DATABITS_8)
                    data_bits = CS8;
                else if(p_cfg->fmt & USERIAL_DATABITS_7)
                    data_bits = CS7;
                else if(p_cfg->fmt & USERIAL_DATABITS_6)
                    data_bits = CS6;
                else if(p_cfg->fmt & USERIAL_DATABITS_5)
                    data_bits = CS5;
                else
                {
                    ALOGE("userial vendor open: unsupported data bits");
                    return -1;
                }

                if(p_cfg->fmt & USERIAL_PARITY_NONE)
                    parity = 0;
                else if(p_cfg->fmt & USERIAL_PARITY_EVEN)
                    parity = PARENB;
                else if(p_cfg->fmt & USERIAL_PARITY_ODD)
                    parity = (PARENB | PARODD);
                else
                {
                    ALOGE("userial vendor open: unsupported parity bit mode");
                    return -1;
                }

                if(p_cfg->fmt & USERIAL_STOPBITS_1)
                    stop_bits = 0;
                else if(p_cfg->fmt & USERIAL_STOPBITS_2)
                    stop_bits = CSTOPB;
                else
                {
                    ALOGE("userial vendor open: unsupported stop bits");
                    return -1;
                }

                ALOGI("userial vendor open: opening %s", vnd_userial.port_name);

                if ((vnd_userial.fd = open(vnd_userial.port_name, O_RDWR)) == -1)
                {
                    ALOGE("userial vendor open: unable to open %s", vnd_userial.port_name);
                    return -1;
                }

                tcflush(vnd_userial.fd, TCIOFLUSH);

                tcgetattr(vnd_userial.fd, &vnd_userial.termios);
                cfmakeraw(&vnd_userial.termios);
                vnd_userial.termios.c_cflag |= (CRTSCTS | stop_bits);
                tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
                tcflush(vnd_userial.fd, TCIOFLUSH);

                tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
                tcflush(vnd_userial.fd, TCIOFLUSH);
                tcflush(vnd_userial.fd, TCIOFLUSH);

                /* set input/output baudrate */
                cfsetospeed(&vnd_userial.termios, baud);
                cfsetispeed(&vnd_userial.termios, baud);
                tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);

            #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
                userial_ioctl_init_bt_wake(vnd_userial.fd);
            #endif

                ALOGI("device fd = %d open", vnd_userial.fd);

                return vnd_userial.fd;
            }
        }
    }
-------------------------------------------------------------------------------------------------->
Userial_vendor.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        void userial_vendor_init(void)
        {
            vnd_userial.fd = -1;
            snprintf(vnd_userial.port_name, VND_PORT_NAME_MAXLEN, "%s", \
                    BLUETOOTH_UART_DEVICE_PORT);                            // 默认是"/dev/ttyO1", 这个会在外面定义
        }

        int userial_set_port(char *p_conf_name, char *p_conf_value, int param)
        {
            strcpy(vnd_userial.port_name, p_conf_value);

            return 0;
        }

        int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param)
        {

            strcpy(fw_patchfile_path, p_conf_value);

            return 0;
        }
    }
----------------------------------------------------------------------------------------------------->
Conf.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        static const conf_entry_t conf_table[] = {
            {"UartPort", userial_set_port, 0},
            {"FwPatchFilePath", hw_set_patch_file_path, 0},
            {"FwPatchFileName", hw_set_patch_file_name, 0},
        #if (VENDOR_LIB_RUNTIME_TUNING_ENABLED == TRUE)
            {"FwPatchSettlementDelay", hw_set_patch_settlement_delay, 0},
        #endif
            {"AP6476_PCM2_Setup", get_pcm2_settings, 0 },
            {(const char *) NULL, NULL, 0}
        };

        /**********************************************************************************************
         *   /home/ballack/prj/rk3288/device/common/bluetooth/libbt/conf/rockchip/rk30sdk/bt_vendor.conf
         *   内容如下：
         *   # UART device port where Bluetooth controller is attached
         *   UartPort = /dev/ttyS0
         *
         *   # Firmware patch file location
         *   FwPatchFilePath = /vendor/firmware/
        **********************************************************************************************/
        void vnd_load_conf(const char *p_path)
        {
            if ((p_file = fopen(p_path, "r")) != NULL)
            {
                p_entry = (conf_entry_t *)conf_table;

                while (p_entry->conf_entry != NULL)
                {
                    // 从bt_vendor.conf中读取配置和conf_table中匹配的name, 并执行对应的函数
                    if (strcmp(p_entry->conf_entry, (const char *)p_name) == 0)     
                    {
                        p_entry->p_action(p_name, p_value, p_entry->param);
                        break;
                    }

                    p_entry++;
                }
            }
        }
    }

--------------------------------------------------------------------------------------------------------->
Upio.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        // 可以看到这个函数  其实就是做了echo 1 > /sys/class/rfkill/rfkill%d/state的动作
        int upio_set_bluetooth_power(int on)
        {
            int sz;
            int fd = -1;
            int ret = -1;
            char buffer = '0';

            switch(on)
            {
                case UPIO_BT_POWER_OFF:
                    buffer = '0';
                    break;

                case UPIO_BT_POWER_ON:
                    buffer = '1';
                    break;
            }

            if (is_emulator_context())
            {
                /* if new value is same as current, return -1 */
                if (bt_emul_enable == on)
                    return ret;

                UPIODBG("set_bluetooth_power [emul] %d", on);

                bt_emul_enable = on;
                return 0;
            }

            /* check if we have rfkill interface */
            if (is_rfkill_disabled())
                return 0;

            if (rfkill_id == -1)
            {
                if (init_rfkill())
                    return ret;
            }

            // 找到/sys/class/rfkill/rfkill%d/type是bluebooth的， 然后打开"/sys/class/rfkill/rfkill%d/state"
            fd = open(rfkill_state_path, O_WRONLY);                             

            if (fd < 0)
            {
                ALOGE("set_bluetooth_power : open(%s) for write failed: %s (%d)",
                        rfkill_state_path, strerror(errno), errno);
                return ret;
            }

            sz = write(fd, &buffer, 1);

            if (sz < 0) {
                ALOGE("set_bluetooth_power : write(%s) failed: %s (%d)",
                        rfkill_state_path, strerror(errno),errno);
            }
            else {
                ret = 0;
                ALOGD("Delay 500ms for bluetooth power up");
                usleep(500*1000);
            }

            if (fd >= 0)
                close(fd);

            return ret;
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Userial.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\hci\src)
->  {
        bool userial_open(userial_port_t port) {       
            int fd_array[CH_MAX];
            for (int i = 0; i < CH_MAX; i++)
                fd_array[i] = -1;

            int num_ports = vendor_send_command(BT_VND_OP_USERIAL_OPEN, &fd_array);

            userial_cb.fd = fd_array[0];
            userial_cb.port = port;
        }
    }
-------------------------------------------------------------------------------------------------------------------->
Bluetooth.h (z:\home\ballack\prj\rk3288\hardware\libhardware\include\hardware)
->  {
        typedef struct {
            /** set to sizeof(bt_callbacks_t) */
            size_t size;
            adapter_state_changed_callback adapter_state_changed_cb;
            adapter_properties_callback adapter_properties_cb;
            remote_device_properties_callback remote_device_properties_cb;
            device_found_callback device_found_cb;
            discovery_state_changed_callback discovery_state_changed_cb;
            pin_request_callback pin_request_cb;
            ssp_request_callback ssp_request_cb;
            bond_state_changed_callback bond_state_changed_cb;
            acl_state_changed_callback acl_state_changed_cb;
            callback_thread_event thread_evt_cb;
            dut_mode_recv_callback dut_mode_recv_cb;
            le_test_mode_callback le_test_mode_cb;
            energy_info_callback energy_info_cb;
        } bt_callbacks_t;
    }
-------------------------------------------------------------------------------------------------------------------->
Btif_dm.c (external\bluetooth\bluedroid\btif\src)
->  {
        /*******************************************************************************
         **
         ** Function         bte_dm_evt
         **
         ** Description      Switches context from BTE to BTIF for all DM events
         **
         ** Returns          void
         **
         *******************************************************************************/

        void bte_dm_evt(tBTA_DM_SEC_EVT event, tBTA_DM_SEC *p_data)
        {
            bt_status_t status;

            /* switch context to btif task context (copy full union size for convenience) */
            status = btif_transfer_context(btif_dm_upstreams_evt, (uint16_t)event, (void*)p_data, sizeof(tBTA_DM_SEC), NULL);

            /* catch any failed context transfers */
            ASSERTC(status == BT_STATUS_SUCCESS, "context transfer failed", status);
        }


        /*******************************************************************************
         **
         ** Function         btif_dm_upstreams_cback
         **
         ** Description      Executes UPSTREAMS events in btif context
         **
         ** Returns          void
         **
         *******************************************************************************/
        static void btif_dm_upstreams_evt(UINT16 event, char* p_param)
        {
            switch (event)
            {
                case BTA_DM_ENABLE_EVT:
                    {
                        btif_enable_bluetooth_evt(p_data->enable.status, p_data->enable.bd_addr);
                    }
            }
        }
    }
-------------------------------------------------------------------------------------------------------------------->
Btif_core.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        void btif_enable_bluetooth_evt(tBTA_STATUS status, BD_ADDR local_bd)
        {
            HAL_CBACK(bt_hal_cbacks, adapter_state_changed_cb, BT_STATE_ON);    // 即调用adapter_state_change_callback
        }
    }
-------------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static void classInitNative(JNIEnv* env, jclass clazz) {
            jclass jniCallbackClass =
                env->FindClass("com/android/bluetooth/btservice/JniCallbacks");
            sJniCallbacksField = env->GetFieldID(clazz, "mJniCallbacks",
                    "Lcom/android/bluetooth/btservice/JniCallbacks;");

            method_stateChangeCallback = env->GetMethodID(jniCallbackClass, "stateChangeCallback", "(I)V");
        }

        static void adapter_state_change_callback(bt_state_t status) {
            if (!checkCallbackThread()) {
                ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
                return;
            }
            ALOGV("%s: Status is: %d", __FUNCTION__, status);

            callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);

            checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
JniCallbacks.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void stateChangeCallback(int status) {
            mAdapterStateMachine.stateChangeCallback(status);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
AdapterState.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        void stateChangeCallback(int status) {
            if (status == AbstractionLayer.BT_STATE_OFF) {
                sendMessage(DISABLED);
            } else if (status == AbstractionLayer.BT_STATE_ON) {
                // We should have got the property change for adapter and remote devices.
                sendMessage(ENABLED_READY);
            } else {
                errorLog("Incorrect status in stateChangeCallback");
            }
        }
    }

private class PendingCommandState extends State {
    public boolean processMessage(Message msg) {
        switch (msg.what) {
            case ENABLED_READY:
                removeMessages(ENABLE_TIMEOUT);
                adapterProperties.onBluetoothReady();
                mPendingCommandState.setTurningOn(false);
                transitionTo(mOnState);
                notifyAdapterStateChange(BluetoothAdapter.STATE_ON);
                break;
            }
        }
    }
}
->  {
        private class OnState extends State {
            @Override
                public void enter() {
                    infoLog("Entering On State");
                    AdapterService adapterService = mAdapterService;
                    adapterService.autoConnect();
                }

            @Override
                public boolean processMessage(Message msg) {
                    AdapterProperties adapterProperties = mAdapterProperties;
                    switch(msg.what) {
                    
                    }
                }
            }
    }
-------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth_bplus\src\com\android\bluetooth\btservice)
->  {
        // 打开蓝牙，如果之前有连接过蓝牙设备，则自动连接！
        public void autoConnect(){
            if (getState() != BluetoothAdapter.STATE_ON){
                errorLog("BT is not ON. Exiting autoConnect");
                return;
            }
            if (isQuietModeEnabled() == false) {
                if (DBG) debugLog( "Initiate auto connection on BT on...");
                autoConnectHeadset();
                autoConnectA2dp();
            }
            else {
                if (DBG) debugLog( "BT is in Quiet mode. Not initiating  auto connections");
            }
        }
    }
-------------------------------------------------------------------------------------------------------------------->
BluetoothSettings.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        public void onBluetoothStateChanged(int bluetoothState) {
            super.onBluetoothStateChanged(bluetoothState);
            updateContent(bluetoothState);
        }

        private void updateContent(int bluetoothState) {
            final PreferenceScreen preferenceScreen = getPreferenceScreen();
            int messageId = 0;

            switch (bluetoothState) {
                case BluetoothAdapter.STATE_ON:
                    if (!mInitialScanStarted) {
                        startScanning();
                    }
            }
        }

        private void startScanning() {
            mLocalAdapter.startScanning(true);
        }
    }
-------------------------------------------------------------------------------------------------------------------->
LocalBluetoothAdapter.java (z:\home\ballack\prj\rk3288\packages\apps\settings\src\com\android\settings\bluetooth)
->  {
        void startScanning(boolean force) {
            // Only start if we're not already scanning
            if (!mAdapter.isDiscovering()) {
                if (!force) {
                    // Don't scan more than frequently than SCAN_EXPIRATION_MS,
                    // unless forced
                    if (mLastScan + SCAN_EXPIRATION_MS > System.currentTimeMillis()) {
                        return;
                    }

                    // If we are playing music, don't scan unless forced.
                    A2dpProfile a2dp = mProfileManager.getA2dpProfile();
                    if (a2dp != null && a2dp.isA2dpPlaying()) {
                        return;
                    }
                }

                if (mAdapter.startDiscovery()) {
                    mLastScan = System.currentTimeMillis();
                }
            }
        }
    }
--------------------------------------------------------------------------------------------------------------------->
BluetoothAdapter.java (z:\home\ballack\prj\rk3288\frameworks\base\core\java\android\bluetooth)
->  {
        public boolean startDiscovery() {
            return mService.startDiscovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
AdapterService.java (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\src\com\android\bluetooth\btservice)
->  {
        public boolean startDiscovery() {
            AdapterService service = getService();
            return service.startDiscovery();
        }
        ->  {
                boolean startDiscovery() {
                    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                            "Need BLUETOOTH ADMIN permission");

                    return startDiscoveryNative();
                }
            }
    }
--------------------------------------------------------------------------------------------------------------------->
com_android_bluetooth_btservice_AdapterService.cpp (z:\home\ballack\prj\rk3288\packages\apps\bluetooth\jni)
->  {
        static JNINativeMethod sMethods[] = {
            {"startDiscoveryNative", "()Z", (void*) startDiscoveryNative},
        }

        static jboolean startDiscoveryNative(JNIEnv* env, jobject obj) {
            int ret = sBluetoothInterface->start_discovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Bluetooth.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        static int start_discovery(void)
        {
            /* sanity check */
            if (interface_ready() == FALSE)
                return BT_STATUS_NOT_READY;

            return btif_dm_start_discovery();
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Btif_dm.c (z:\home\ballack\prj\rk3288\external\bluetooth\bluedroid\btif\src)
->  {
        bt_status_t btif_dm_start_discovery(void)
        {
            /* find nearby devices */
            BTA_DmSearch(&inq_params, services, bte_search_devices_evt);
        }
    }
--------------------------------------------------------------------------------------------------------------------->
Hardware.c (z:\home\ballack\prj\rk3288\device\common\bluetooth\libbt\src)
->  {
        void hw_config_start(void) {
            p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
            p_buf->offset = 0;
            p_buf->layer_specific = 0;
            p_buf->len = HCI_CMD_PREAMBLE_SIZE;

            p = (uint8_t *) (p_buf + 1);
            UINT16_TO_STREAM(p, HCI_RESET);
            *p = 0; /* parameter length */

            hw_cfg_cb.state = HW_CFG_START;

            bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);
        }
    }
----------------------------------------------------------------------------------------------------->
vnd_rk30sdk.txt (/home/ballack/prj/rk3288/device/common/bluetooth/libbt/include)
->  {
        BLUETOOTH_UART_DEVICE_PORT = "/dev/ttyS0"
        FW_PATCHFILE_LOCATION = "/vendor/firmware/"
        UART_TARGET_BAUD_RATE = 1500000
        LPM_IDLE_TIMEOUT_MULTIPLE = 5
        BTVND_DBG = FALSE
        BTHW_DBG = TRUE
        VNDUSERIAL_DBG = FALSE
        UPIO_DBG = FALSE
        BT_WAKE_VIA_PROC = TRUE
        SCO_PCM_ROUTING = 0
        SCO_PCM_IF_CLOCK_RATE = 1
        SCO_PCM_IF_FRAME_TYPE = 0
        SCO_PCM_IF_SYNC_MODE = 1
        SCO_PCM_IF_CLOCK_MODE = 1
        PCM_DATA_FMT_SHIFT_MODE = 0
        PCM_DATA_FMT_FILL_BITS = 0
        PCM_DATA_FMT_FILL_METHOD = 0
        PCM_DATA_FMT_FILL_NUM = 0
        PCM_DATA_FMT_JUSTIFY_MODE = 0
    }

